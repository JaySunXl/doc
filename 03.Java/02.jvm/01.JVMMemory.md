---
title: JVM2:内存结构
date: 2017-11-06
tags:
- Java
- JVM
---
<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [内存结构](#内存结构)
    - [程序计数器(Program Counter Register)](#程序计数器program-counter-register)
    - [VM栈(VM Stacks)](#vm栈vm-stacks)
    - [堆内存(Heap)](#堆内存heap)
    - [方法区(Method Area)](#方法区method-area)
    - [运行时常量池](#运行时常量池)
    - [本地方法栈(Native Method Stacks)](#本地方法栈native-method-stacks)
    - [直接内存](#直接内存)
- [比较](#比较)
- [内存溢出异常](#内存溢出异常)
    - [一些代码](#一些代码)
- [参考](#参考)

<!-- /TOC -->
</details>

# 内存结构

![](https://gitee.com/LuVx/img/raw/master/jvmme.png)

* 堆内存
    * 新生代(8:1:1)
        * Eden空间
        * From Survivor
        * To Survivor
    * 老年代
* 方法区
* 栈
    * java虚拟机栈
    * 本地方法栈



| 区域         | 作用                                              | 共享性 | 存储内容                                              |
| ------------ | ------------------------------------------------- | ------ | ----------------------------------------------------- |
| 堆内存       | 存放对象实例,可以细分为新生代和老年代             | √      | new出来的对象(属性,方法的地址(指向方法区))            |
| 方法区       | 内有运行时常量池,也有人称之为永久代               | √      | 类信息(属性,方法),常量,static变量                     |
| 运行时常量池 | 方法区的一部分                                    | √      | 运行时常量池(各种字面量和符号引用)                    |
| 程序计数器   | 比较小的内存区域,指示当前线程所执行的字节码的位置 | ×      | 正在执行的VM字节码指令地址(Java方法,native方法时为空) |
| VM栈         | 记录方法调用                                      | ×      | 局部变量表,对象的引用指针                             |
| 本地方法栈   | 执行Native方法时使用                              | ×      | -                                                     |


![内存结构](https://gitee.com/LuVx/img/raw/master/jvm01.png)

**新生代和老年代的特征**

## 程序计数器(Program Counter Register)

一块较小的内存空间, 属于线程私有.

字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令, 分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成.
如果线程正在执行一个java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址;

如果是Native方法,则计数器为空;多线程时, 存在多个程序计数器.

此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域.

## VM栈(VM Stacks)

![](https://gitee.com/LuVx/img/raw/master/jvm/jvm_stack.png)

线程私有, 生命周期与线程相同

虚拟机栈描述的是Java方法执行的内存模型:每个方法被执行的时候都会同时创建一个栈帧(Stack Frame)用于存储局部变量表、操作栈、动态链接、方法出口等信息.

每一个方法被调用直至执行完成的过程, 就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程.

局部变量表所需的内存空间在编译期间完成分配,当进入一个方法时该方法对应的需要在栈帧中分配多大的局部变量空间是完全确定的.

对这个区域规定了两种异常状况:
如果线程请求的栈深度大于虚拟机所允许的深度, 将抛出`StackOverflowError`异常;
如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展, 只不过Java虚拟机规范中也允许固定长度的虚拟机栈), 当扩展时无法申请到足够的内存时会抛出`OutOfMemoryError`异常.

> 栈帧: 一个栈帧随着一个方法的调用开始而创建,这个方法调用完成而销毁.栈帧内存放着方法中的局部变量,操作数栈等数据

方法体内, 基本类型不同的变量存储位置也有所不同:

基本数据类型的局部变量以及数据都是直接存储在内存中的栈的局部变量表中, 而且数据在在当前线程下是共享的, 如定义了两个基本类型的局部变量, 值一样, 那么这两个变量的指向是相同的

修改这样的局部变量时, 并不是直接改变数值的内容, 而是先找到有没有这样的数值, 没有才会开辟内存存储新数据, 然后确定指向

而基本类型的成员变量则是和对象一样存储在堆中, 其生命周期和对象相同

基本类型的静态变量则是存储在方法区的运行时常量池中, 其生命周期和类相同

对于引用对象, 会再 jvm 栈中开辟空间存储引用, 而具体的对象在堆中, 之后再引用指向这个对象, 因此对于对象及数组, 栈中引用不存储真实数据, 而是对象的地址

## 堆内存(Heap)

Java堆是被所有线程共享的一块内存区域, 在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例, 几乎所有的对象实例都在这里分配内存.

Java堆是垃圾收集器管理的主要区域, 因此很多时候也被称做"GC堆"
多采用分代收集策略,所以细分为新生代和老年代,新生代再细分可分为Eden空间,From Survivor空间,To Survivor空间,在GC的复制算法中起着重要作用,HotSpot VM默认的Eden和Survivor大小比例为`8:1`

堆内存可以是物理上不连续的内存空间, 逻辑上连续即可,

在堆中没有内存完成实例分配, 并且堆也无法再扩展时, 将会抛出`OutOfMemoryError`异常

## 方法区(Method Area)

与Java堆一样, 是各个线程共享的内存区域, 它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据,有时也被称为`永久代(PermGen)`

Java虚拟机规范对这个区域的限制非常宽松, 除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外, 还可以选择不实现垃圾收集

这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载

当方法区无法满足内存分配需求时, 将抛出`OutOfMemoryError`异常


![](https://gitee.com/LuVx/img/raw/master/classloader0.png)

![](https://gitee.com/LuVx/img/raw/master/jvm02.png)

> 对方法区和永久区的理解以及它们之间的关系
> 永久代是HotSpot的概念, 方法区是Java虚拟机规范中的定义, 是一种规范, 而永久代是一种实现, 一个是标准一个是实现
> 虽然方法区也常被称为永久代, 实际上两者并不等价, 仅仅是因为方便像堆一样管理这片内存, 从而将GC分代收集扩展到方法区

## 运行时常量池

是方法区的一部分,存放编译期生成的各种字面量和符号引用,当JVM运行的时候会将这些常量池的信息加载进方法区.

当方法区无法满足内存分配需求时,抛出`OutOfMemoryError`

## 本地方法栈(Native Method Stacks)

虚拟机栈为虚拟机执行Java方法(也就是字节码)服务, 而本地方法栈则是为虚拟机使用到的Native方法服务

异常抛出类型和JVM栈相同

## 直接内存

不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域,但是这部分内存也被频繁的使用.

也可能导致`OutOfMemoryError`异常出现

# 比较

* 栈内存用来存储局部变量和方法调用.
* 堆内存用来存储Java中的对象.无论是成员变量,局部变量,还是类变量,它们指向的对象都存储在堆内存中.
* 基本类型的变量: 变量和引用存在栈中; 基本类型的常量: 引用在栈中, 常量在常量池中.

# 内存溢出异常

`Exception in thread "main": java.lang.OutOfMemoryError: Java heap space`

原因: 对象不能被分配到堆内存中

`Exception in thread "main": java.lang.OutOfMemoryError: PermGen space`

原因: 类或者方法不能被加载到永久代.它可能出现在一个程序加载很多类的时候, 比如引用了很多第三方的库;

`Exception in thread "main": java.lang.OutOfMemoryError: Requested array size exceeds VM limit`

原因: 创建的数组大于堆内存的空间

`Exception in thread "main": java.lang.OutOfMemoryError: request <size> bytes for <reason>. Out of swap space?`

原因: 分配本地分配失败.JNI、本地库或者Java虚拟机都会从本地堆中分配内存空间.

`Exception in thread "main": java.lang.OutOfMemoryError: <reason> <stack trace>(Native method)`

原因: 同样是本地方法内存分配失败, 只不过是JNI或者本地方法或者Java虚拟机发现

`java.lang.OutOfMemoryError: unable to create new native thread`

原因: 创建了太多的线程,而能创建的线程数是有限制的,导致了异常的发生

## 一些代码

```Java
long maxMemory = Runtime.getRuntime().maxMemory();
long totalMemory = Runtime.getRuntime().totalMemory();
System.out.println("MAX_MEMORY = " + maxMemory + "(字节)、" + (maxMemory / (double) 1024 / 1024) + "MB");
System.out.println("TOTAL_MEMORY = " + totalMemory + "(字节)、" + (totalMemory / (double) 1024 / 1024) + "MB");
```


# 参考

1. 深入理解Java虚拟机

[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)