<details>
<summary>点击展开目录</summary>
<!-- TOC -->

    - [特点](#特点)
- [Scheduled](#scheduled)
    - [并行](#并行)
- [Tips](#tips)
- [Usage](#usage)
    - [原理](#原理)
    - [QA](#qa)
- [参考](#参考)

<!-- /TOC -->
</details>

## 特点

1. 默认情况下单线程(可配置多线程), 单个任务执行时间超过间隔, 造成阻塞, 前一任务执行后会立即开始下一次执行
2. 默认新情况下单线程, 多个任务串行执行
3. 单线程时, 相同表达式的定时任务, 串行执行


# Scheduled


```Java
@EnableScheduling

@Scheduled(fixedRate = 30 * 1000)
每30秒执行一次

@Scheduled(fixedDelay = 5 * 1000)
执行结束后延迟5秒后再次执行

@Scheduled(initialDelay=1 * 1000, fixedRate=5 * 1000)
等待1秒后开始执行第一次, 之后每5秒执行一次

@Scheduled(cron = "0 50 16 * * ?")

```



cron表达式有至少6个(也可能7个)有空格分隔的时间元素
从左往右依次代表

1. Seconds Minutes Hours DayofMonth Month DayofWeek Year
2. Seconds Minutes Hours DayofMonth Month DayofWeek

`*`: 匹配任意值
`?`: 只用于日期和星期字段
`,`: 指定执行
`-`: 范围执行
`/`: 间隔执行, `x/y`表示从x开始每隔y触发

Usage:

`0 0-5 14 * * ?` 在每天下午2时到下午2:05内, 每1分钟执行次
`0 0/5 14,18 * * ?` 每天14, 18时0分开始, 每隔5分钟一次



## 并行

定时任务在同一线程中串行执行, 在多定时任务时可能出现不执行的情况
原因:

```Java
if (this.taskScheduler == null) {
    this.localExecutor = Executors.newSingleThreadScheduledExecutor();
    this.taskScheduler = new ConcurrentTaskScheduler(this.localExecutor);
}
```

解决1:
```Java
@Configuration
public class SchedulingConfig implements SchedulingConfigurer {
    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        taskRegistrar.setScheduler(Executors.newScheduledThreadPool(5));
    }
}
```

解决2
```Java
@Component
@EnableScheduling
@EnableAsync
public class Task1 {
    @Async
    @Scheduled(cron = "0 * * * * ?")
    public void execute() {
    }

    @Async
    @Scheduled(cron = "10 * * * * ?")
    public void execute1() {
    }
}
```

类上添加`@EnableAsync`注解, 任务方法上添加`@Async`注解

解决3(经验证无效):
```Java
@Component
@Configuration
@EnableScheduling
public class SchedulingConfig {
    @Scheduled(cron = "0 0/10 * * * ?")
    public void method() {
        ......;
    }
}
```


# Tips

同一任务前一周期没有执行完,过去接下来n次任务开始时间, 那么后n次的任务会推迟并累积, 会像赶时间一样将这n次任务执行掉.

# Usage

```Java
private static int i = 1;

@Scheduled(fixedRate = 3 * 1000)
public void method() throws Exception {
    System.out.println("time: " + System.currentTimeMillis());
    if (i == 1) {
        Thread.sleep(21 * 1000);
        i = 0;
    }
    method1();
}

private static int aa = 1;
public void method1() {
    aa++;
    System.out.println(Thread.currentThread().getName() + " :" + aa);
}
```

## 原理


扫描所有使用了`@Scheduled`注解的方法, 并解析响应的 cron 表达式
```Java
// 继承了 `BeanPostProcessor` 类
// ScheduledAnnotationBeanPostProcessor#postProcessAfterInitialization
public Object postProcessAfterInitialization(Object bean, String beanName) {
    // 省略
    Class<?> targetClass = AopProxyUtils.ultimateTargetClass(bean);
    if (!this.nonAnnotatedClasses.contains(targetClass)) {
        Map<Method, Set<Scheduled>> annotatedMethods = MethodIntrospector.selectMethods(targetClass,
                (MethodIntrospector.MetadataLookup<Set<Scheduled>>) method -> {
                    Set<Scheduled> scheduledMethods = AnnotatedElementUtils.getMergedRepeatableAnnotations(
                            method, Scheduled.class, Schedules.class);
                    return (!scheduledMethods.isEmpty() ? scheduledMethods : null);
                });
        if (annotatedMethods.isEmpty()) {// 无被注解了的方法, 放入 set 中存储
            this.nonAnnotatedClasses.add(targetClass);
        }
        else {// 遍历所有定时任务方法, 解析cron 表达式, 放入Set<ScheduledTask>变量中
            annotatedMethods.forEach((method, scheduledMethods) ->
                    scheduledMethods.forEach(scheduled -> processScheduled(scheduled, method, bean)));
        }
    }
    return bean;
}
```

获取到所有被注解的方法后, 使用 `processScheduled`方法, 根据不同的 cron 表达式类型, 进行处理并放入任务列表中

大致如: `tasks.add(this.registrar.scheduleCronTask(new CronTask(runnable, new CronTrigger(cron, timeZone))));`

执行任务:

`ScheduledAnnotationBeanPostProcessor` 类还实现了 `ApplicationListener` 接口, 通过

`onApplicationEvent -> finishRegistration -> ScheduledTaskRegistrar#afterPropertiesSet -> ScheduledTaskRegistrar#scheduleTasks`
找到以下方法:
```Java
protected void scheduleTasks() {
    if (this.taskScheduler == null) {// 检查线程池, 没有则创建一个线程的线程池
        this.localExecutor = Executors.newSingleThreadScheduledExecutor();
        this.taskScheduler = new ConcurrentTaskScheduler(this.localExecutor);
    }
    if (this.triggerTasks != null) {
        for (TriggerTask task : this.triggerTasks) {
            addScheduledTask(scheduleTriggerTask(task));
        }
    }
    if (this.cronTasks != null) {
        for (CronTask task : this.cronTasks) {
            addScheduledTask(scheduleCronTask(task));// 也到了scheduleCronTask这个方法上
        }
    }
    // 省略其他中任务
}
```
`scheduleCronTask`方法中执行了调度器的调度方法, 
即 `ThreadPoolTaskScheduler#schedule(java.lang.Runnable, org.springframework.scheduling.Trigger)` 方法, 如下:

```Java
public ScheduledFuture<?> schedule(Runnable task, Trigger trigger) {
    ScheduledExecutorService executor = getScheduledExecutor();
    ErrorHandler errorHandler = this.errorHandler;
    if (errorHandler == null) {
        errorHandler = TaskUtils.getDefaultErrorHandler(true);
    }
    // 省略异常处理
    return new ReschedulingRunnable(task, trigger, executor, errorHandler).schedule();
}
```

此方法中, 创建`ReschedulingRunnable`对象, 其实现了`Runnable`接口

其中以下两个方法至关重要:

```Java
public ScheduledFuture<?> schedule() {
    synchronized (this.triggerContextMonitor) {
        // 计算下次执行时间, 内部首先获取上一次的执行时间, 首次执行则会使用当前时间
        this.scheduledExecutionTime = this.trigger.nextExecutionTime(this.triggerContext);
        if (this.scheduledExecutionTime == null) {
            return null;
        }
        // 计算下次执行时间
        long initialDelay = this.scheduledExecutionTime.getTime() - System.currentTimeMillis();
        // 线程池执行任务
        this.currentFuture = this.executor.schedule(this, initialDelay, TimeUnit.MILLISECONDS);
        return this;
    }
}
```

```Java
@Override
public void run() {
    Date actualExecutionTime = new Date();
    super.run();
    Date completionTime = new Date();
    synchronized (this.triggerContextMonitor) {
        Assert.state(this.scheduledExecutionTime != null, "No scheduled execution");
        // 更新下次执行
        this.triggerContext.update(this.scheduledExecutionTime, actualExecutionTime, completionTime);
        if (!obtainCurrentFuture().isCancelled()) {
            schedule();
        }
    }
}
```

可以看出, 在调度方法中计算好了下次执行时间, 但在任务的具体内容执行完成后才更新执行实现, 同时再次调用调度方法

因此当任务阻塞时, 无法更新下次执行时间

## QA

定时任务阻塞会有什么影响？
多个定时任务的情况下如何运行的？
具有相同表达式的定时任务，他们的执行顺序如何？
为什么async异步任务没有生效？


# 参考

https://segmentfault.com/a/1190000013077817

[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)
