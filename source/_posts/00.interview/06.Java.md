---
title: 面试准备:Java
date: 2018-03-27
tags:
- Java
categories:
- 面试
---

<!-- TOC -->

- [关键字](#关键字)
    - [static](#static)
    - [abstract](#abstract)
    - [native](#native)
- [异常](#异常)
- [集合](#集合)
- [JVM](#jvm)
- [GC](#gc)
- [并发编程](#并发编程)
- [I/O](#io)
    - [序列化](#序列化)
- [OO](#oo)
- [泛型](#泛型)
- [反射 内省](#反射-内省)

<!-- /TOC -->

[TOC]

# 关键字

## static

可以用于修饰类,变量,方法,代码块,被修饰内容全局唯一,只加载一次,不依赖实例对象,生命周期为类级别

* 类: 被修饰的类只能作为内部类,且其中只能访问静态变量和静态方法,不依赖于外部类,区别于普通内部类需在其自身构造函数中构造外部类对象
* 方法: 存在于普通类和静态内部类中,被动执行(被调用执行).不存在于普通内部类中
* 变量: 可以存在于普通类和静态内部类
* 代码块:在加载类的时候主动执行,只在第一次创建类对象时调用,可以使用定义在其前面的静态变量,对于其后面的静态变量,只能赋值而不能访问.

> 非静态代码块:在创建对象时执行,每创建一个对象都会执行一次.执行顺序参看`jvm类加载`内容
> 静态代码块的共同点:

* 构造方法前执行
* 可以定义多个

## abstract

用于修饰方法,使得其只有声明而没有实现, 具体在继承了该类的子类中实现.

不能同时使用的修饰符:

* final:不可重写
* private:不可继承
* static:不可重写

以上修饰符的使用都会导致子类无法重写父类的abstract方法.

## native

本地方法, 这种方法和抽象方法极其类似, 它也只有方法声明, 没有方法实现,
与抽象方法不同的是, 它把具体实现移交给了本地系统的函数库, 而没有通过虚拟机, 可以说是Java与其它语言通讯的一种机制.
使用过程:

1. 编写java代码,声明native方法
2. javac 编译代码生成class文件
3. `javah -jni class文件名`,生成`.h`文件
4. 依据`.h`文件编写c代码
5. 编译c代码为动态链接库文件

> Java语言本身是不能直接操作或访问系统底层的数据,但可以通过JNI(Java Native Interface)调用其他语言间接实现,如C等
> 通常是为了提高性能或隐藏敏感代码而使用

**Object的hashcode()是怎么计算的?**

hashcode是一个本地方法,通过生成`.h`文件获得c代码的信息最终找到源码:
[源码:hashcode](http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/f2110083203d/src/share/vm/runtime/synchronizer.cpp#l555)的`get_next_hash`函数
不能认为hash的结果就是对象的内存地址,只能认为与其有关系.

# 异常

[异常总结](../03.Java/00.Foundation/Foundation_Exception.md)

# 集合

[总结总结](../03.Java/01.readsource)

# JVM

[JVM总结](../03.Java/02.jvm)

# GC

# 并发编程

ReentrantLock,ArrayBlockingQueue,LinkedBlockingQueue源码
volatile,内存屏障

**进程和线程的区别**

进程是分配资源的最小单元
线程是调度的最小单元

在操作系统设计上, 从进程演化出线程, 最主要的目的就是更好的支持SMP以及减小(进程/线程)上下文切换开销。
进程拥有一个独立的虚拟内存地址空间

[深入理解进程和线程](https://blog.csdn.net/zdy0_2004/article/details/44259391)

# I/O

[IO](../03.Java/IO)

**Java中有几种类型的流?JDK为每种类型的流提供了一些抽象类以供继承, 请说出他们分别是哪些类?**

* 字节流:InputStream,OutputStream,可以处理任何类型的对象
* 字符流:Reader,Writer,只能用于处理字符

> 不能直接处理Unicode字符, 而字符流就可以

## 序列化

**什么是java序列化, 如何实现java序列化?**

[序列化与反序列化](../03.Java/Cache/01.Serialize.md)

**序列化的方式**

* 实现`Serializable`接口
* 实现`Externalizable`接口,该接口继承自Serializable,并增加writeExternal和readExternal方法
* json实现
* protostuff实现

# OO

[面向对象](../03.Java/OO.md)

# 泛型

[泛型](../03.Java/泛型.md)

# 反射 内省

[反射](../03.Java/reflect.md)
[内省](../03.Java/内省.md)

Java内存模型, 方法区存什么;

CMS垃圾回收过程;

Full GC次数太多了, 如何优化;

直接内存如何管理的;

如果你的项目出现了内存泄露, 怎么监控这个问题呢;

标记清除和标记整理的区别和优缺点, 为何标记整理会发生stop the world;

JDK中哪些实现了单例模式?

Spring IoC涉及到的设计模式;(工厂模式、单利模式。。)

如何保证分布式缓存的一致性(分布式缓存一致性hash算法?)?分布式session实现?

Java 8流式迭代的好处?

说一下TreeMap的实现原理?红黑树的性质?红黑树遍历方式有哪些?如果key冲突如何解决?setColor()方法在什么时候用?什么时候会进行旋转和颜色转换?

Spring的bean的创建时机?依赖注入的时机?

序列化和反序列化底层如何实现的(ObjectOutputStream 、ObjectInputStream、 readObject  writeObject);

如何调试多线程的程序;

一个Controller调用两个Service, 这两Service又都分别调用两个Dao, 问其中用到了几个数据库连接池的连接?

Java Collections和Arrays的sort方法默认的排序方法是什么;

引用计数法与GC Root可达性分析法区别;

浅拷贝和深拷贝的区别;

反射的作用与实现原理;

Java中的回调机制;

模板方法模式;

开闭原则说一下;

KMP算法(一种改进的字符串匹配算法);

JMM里边的原子性、可见性、有序性是如何体现出来的, JMM中内存屏障是什么意思

软引用可以实现缓存
弱引用可以用来在回调函数中防止内存泄露


[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)