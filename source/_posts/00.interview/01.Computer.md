---
title: 面试准备:计算机网络
date:
tags:
categories:
- 面试
---
<!-- TOC -->

- [OSI网络体系结构与TCP/IP协议模型](#osi网络体系结构与tcpip协议模型)
- [端口](#端口)
- [应用层](#应用层)
    - [DHCP](#dhcp)
    - [DNS](#dns)
    - [FTP](#ftp)
    - [SMTP,IMAP,POP3](#smtpimappop3)
    - [Http[s]](#https)
        - [Http](#http)
        - [Https](#https)
- [传输层](#传输层)
    - [TCP](#tcp)
        - [可靠性传输](#可靠性传输)
        - [流量控制](#流量控制)
        - [拥塞控制](#拥塞控制)
    - [UDP](#udp)
    - [多路复用和多路分解](#多路复用和多路分解)
- [网络层](#网络层)
    - [IP](#ip)
    - [ARP](#arp)
    - [ICMP](#icmp)
        - [Traceroute](#traceroute)
    - [路由器](#路由器)
- [网络接口层](#网络接口层)
- [参考](#参考)

<!-- /TOC -->

# OSI网络体系结构与TCP/IP协议模型
![](https://raw.githubusercontent.com/LuVx21/doc/master/source/_posts/00.interview/img/osi.png)

OSI:Open System Interconnection(开放式系统互联)
* 应用层
* 表示层
* 会话层
* 传输层:在源端与目的端之间提供可靠的透明数据传输,使上层服务用户不必关系通信子网的实现细节,应用进程间的逻辑通信
* 网络层:主机间的逻辑通信
* 数据链路层
* 物理层

# 端口

|port|service|port|service|
|:---|:---|:---|:---|
|21|ftp|22|ssh|
|23|telnet(远程登录服务)|25|SMTP|
|53|DNS域名服务|80|http|
|110|POP3|443|https|
|1080|scokets|1521|Oracle数据库服务|
|2181|zookeeper服务端口|3306|MySQL数据库服务|
|6379|Redis数据库服务|5672|rabbitmq 服务端口|
|8080|web服务器常用|||
|15672|rabbitmq 管理插件|20880|dubbo 协议|


# 应用层

|协议|名称|端口号|传输层协议|备注|
|:---|:---|:---|:---|:---|
|DNS|域名解析系统|53|UDP/TCP|长度超过 512 字节时使用 TCP|
|DHCP|动态主机配置协议|67/68|UDP|域名解析|
|SNMP|简单网络管理协议|161/162|UDP|用于管理网络设备|
|FTP|文件传输协议|20/21|TCP|控制连接 21,数据连接 20|
|TFTP|简单文件传输协议|69|UDP||
|TELNET|远程终端协议|23|TCP||
|HTTP|超文本传送协议|80|TCP||
|HTTPS|超文本传输安全协议|443|TCP/TSL||
|SMTP|简单邮件传输协议|25|TCP||
|IMAP|网际报文存取协议|143|TCP||
|POP3|邮件读取协议|110|TCP||

P2P:点对点传输

## DHCP

动态主机配置协议,提供了即插即用的连网方式,用户不再需要去手动配置 IP 地址等信息.
DHCP 配置的内容不仅是 IP 地址,还包括子网掩码,默认路由器 IP 地址,域名服务器的 IP 地址。
工作方式如下：

需要 IP 地址的主机广播发送 DHCP 发现报文（将目的地址置为全 1,即 255.255.255.255:67,源地址设置为全 0,即 0.0.0.0:68）,DHCP 服务器收到发现报文之后,则在 IP 地址池中取一个地址,发送 DHCP 提供报文给该主机。


## DNS

* 主机向本地域名服务器解析的过程采用递归
* 本地域名服务器向其它域名服务器解析可以使用递归和迭代两种方式.
    * 迭代的方式下,本地域名服务器向一个域名服务器解析请求解析之后,结果返回到本地域名服务器,然后本地域名服务器继续向其它域名服务器请求解析；
    * 递归的方式下,结果不是直接返回的,而是继续向前请求解析,最后的结果才会返回.

> DNS 在解析的过程使用 UDP 进行传输,因为 UDP 最大只支持 512 字节的数据,如果超过的话就需要使用 TCP 传输.

## FTP

FTP 在运输层使用 TCP,并且需要建立两个并行的 TCP 连接：控制连接和数据连接.控制连接在整个会话期间一直保持打开,而数据连接在数据传送完毕之后就关闭.控制连接使用端口号 21,数据连接使用端口号 20.

## SMTP,IMAP,POP3

一个电子邮件系统由三部分组成：用户代理,邮件服务器以及邮件发送协议和读取协议.其中发送协议常用 SMTP,读取协议常用 POP3 和 IMAP.


## Http[s]

### Http

Http协议运行在TCP之上,明文传输,客户端与服务器端都无法验证对方的身份;

HTTP工作流程
HTTP请求格式
HTTP 1.1中的8种请求方式
HTTP响应格式
HTTP中重要的请求头和响应头字段
HTTP常用状态码及其含义

***HTTP1.0 HTTP 1.1 HTTP 2.0***

1.0:

* 使用keep-alive参数来告知服务器端要建立一个长连接

1.1:

* 默认支持长连接

* 支持只发送header信息(不带任何body信息),如果服务器认为客户端有权限请求服务器,则返回100,否则返回401.客户端如果接受到100,才开始把请求body发送到服务器.

* 支持传送内容的一部分,即只请求需要的部分,不请求的可能是已经有了.

* HTTP1.0是没有host域的,HTTP1.1才支持这个参数.

  <!--TODO-->

2.0:

* 多路复用,同一个连接并发处理多个请求
* 支持header数据的压缩
* 服务器推送

### Https

[http](../01.CS/HTTP.md)

# 传输层

![](https://raw.githubusercontent.com/LuVx21/doc/master/source/_posts/00.interview/img/protocol.jpg)

HTTP是应用层协议,其传输都是被包装成TCP协议传输,可以用SOCKET实现HTTP,

TCP:传输控制协议, 提供的是面向连接,可靠的字节流服务(把应用层传下来的报文看成字节流,把字节流组织成大小不等的数据块).提供超时重发,丢弃重复数据,检验数据,流量控制,拥塞控制,提供全双工通信等功能,保证数据能从一端传到另一端
UDP:用户数据报协议, 是一个无连接的不可靠的面向数据报(对于应用程序传下来的报文不合并也不拆分,只是添加 UDP 首部),尽最大可能交付,没有拥塞控制的协议

## TCP

Transmission Control Protocol(传输控制协议),传输层协议

三次握手:你好?我好,你好?我也好!
![](https://raw.githubusercontent.com/LuVx21/doc/master/source/_posts/00.interview/img/tcp_conn.png)

第一次握手:客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认;
第二次握手:服务器收到syn包,必须确认客户的SYN(ack=j+1),同时自己也发送一个SYN包(syn=k),即SYN+ACK包,此时服务器进入SYN_RECV状态;
第三次握手:客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手,

> **为什么3次,而不是2次**
>
> 防止已失效的链接请求报文突然又传送到了服务端,从而产生错误
> 假设客户端的某次请求因为网络延迟直至连接断开后才被服务端收到,服务端则返回响应,若是两次握手,服务端的这次响应就会创建新的连接,并处于等待客户端的请求的状态,但实际上客户端并没有发出请求,造成服务端空等待.



四次挥手:撤了,再见?OK,再见!我也撤了,再见?OK,再见!

![](https://raw.githubusercontent.com/LuVx21/doc/master/source/_posts/00.interview/img/tcp_release.jpg)

1. A 发送连接释放报文段,FIN=1.
2. B 收到之后发出确认,此时 TCP 属于半关闭状态,B 能向 A 发送数据但是 A 不能向 B 发送数据.
3. 当 B 要不再需要连接时,发送连接释放请求报文段,FIN=1.
4. A 收到后发出确认,进入 TIME-WAIT 状态,等待 2MSL 时间后释放连接.
5. B 收到 A 的确认后释放连接.

> **为什么四次挥手**
>
> 客户端发送了 FIN 连接释放报文之后,服务器收到了这个报文,就进入了 CLOSE-WAIT 状态.这个状态是为了让服务器端发送还未传送完毕的数据,传送完毕之后,服务器会发送 FIN 连接释放报文.

> **TIME_WAIT**
>
> 客户端接收到服务器端的 FIN 报文后进入此状态,此时并不是直接进入 CLOSED 状态,还需要等待一个时间计时器设置的时间 2MSL.这么做有两个理由：
>
> * 确保最后一个确认报文段能够到达.如果 B 没收到 A 发送来的确认报文段,那么就会重新发送连接释放请求报文段,A 等待一段时间就是为了处理这种情况的发生.
> * 等待一段时间是为了让本连接持续时间内所产生的所有报文段都从网络中消失,使得下一个新的连接不会出现旧的连接请求报文段.

### 可靠性传输

**工作原理**

停止等待协议: 发送完一个分组就停止发送,等待对方的确认,只有对方确认过,才发送下一个分组,具有超时重传等机制,但对信道的利用率太低

连续ARQ协议: Automatic Repeat-reQuest,自动重传请求,发送方维护一个窗口,在窗口内的多个分组能被发送出去,没收到一个确认,窗口往后滑动一个分组

滑动窗口协议:发送方和接收方之间各自维持一个滑动窗口,其滑动是以字节为单位,允许发送方在停止并等待确认前发送多个数据分组,之后在收到确认后,发送窗口才会向前滑动几个分组,超时未收到确认时,会依据Go-back-N（回退N）机制,回到最后接收到确认的地方进行重传

保证数据传输的正确性,从而提供可靠的传输
提高信道利用率和吞吐量,并起到控制流量的作用

![](https://raw.githubusercontent.com/LuVx21/doc/master/source/_posts/00.interview/img/slim_form.jpg)

**TCP可靠传输是如何实现的**

* 数据包校验
* 对失序数据包重排序
* 丢弃重复数据
* 应答机制
* 超时重发
* 流量控制

### 流量控制

流量控制: 让发送方的发送速率不要太快,让接收方来得及接受.

TCP连接的每一方都有固定大小的缓冲空间. TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据,这可以防止较快主机致使较慢主机的缓冲区溢出.是点对点通信量的控制.

### 拥塞控制

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小,从而影响发送方的发送速率.将窗口字段设置为 0,则发送方不能发送数据.
TCP使用的流量控制协议是可变大小的滑动窗口协议,窗口单位是字节,不是报文段,发送方的发送窗口不能超过接收方给出的接收窗口的数值

拥塞控制:防止过多的数据注入网络中,这样可以使网络中的路由器或链路不致过载.是一个全局性的过程.

![](https://raw.githubusercontent.com/LuVx21/doc/master/source/_posts/00.interview/img/congestion.png)

控制方法:
* 慢启动:此方法适用阶段,发送数量翻倍增长
* 拥塞避免:此方法使发送数量每次加1
* 快重传:发送方连续收到3个来自接收方的确认,就会重传
* 快恢复:丢失个别报文而不是拥塞,因此执行快恢复,此后直接进入拥塞避免,不会从慢启动开始

![](https://raw.githubusercontent.com/LuVx21/doc/master/source/_posts/00.interview/img/repost.png)


## UDP

User Datagram Protocol,用户数据报协议,传输层协议

和TCP协议的区别:
* TCP面向连接,UDP无连接
* TCP可靠,UDP不可靠
* TCP只支持点对点通信,UDP支持一对一,一对多,多对一,多对多的通信模式
* TCP是面向字节流的,UDP是面向报文的
* TCP有拥塞控制机制;UDP没有拥塞控制,适合媒体通信
* TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大

## 多路复用和多路分解

主机间的通信实质上是主机上应用程序间的通信,正是多路分解与多路复用的存在保证了对应应用程序间正确通信.
当程序需要使用网络时,会向OS申请,OS会创建socket,并返回其id,程序根据此id读写数据,即收发信息.socket都有唯一标识符—端口号.

多路复用:从源端各socket收集数据,为每个数据块封装上首部信息从而生成报文段,之后传给网络层.

多路分解:接收端检查字段,检查端口号并标记出消息对应的socket,之后发送到该socket

# 网络层

IP (Internet Protocol):网络协议
ARP(Address Resolution Protocol):地址解析协议
ICMP(Internet Control Message Protocol):网际控制报文协议
IGMP(Internet Group Management Protocol):网际组管理协议
RARP协议和BOOTP协议

## IP

A,B,C是基本类,D,E类作为多播和保留使用,为特殊地址

每个IP地址包括两个标识码(ID),即网络ID和主机ID,
同一个物理网络上的所有主机都使用同一个网络ID,网络上的一个主机(包括网络上工作站,服务器和路由器等)有一个主机ID与其对应,

IP地址长度为32位,分为4组书写.A~E类地址的特点如下:

* A类地址:网络id8位,以0开头,第一个字节范围:0~127
* B类地址:网络id16位,以10开头,第一个字节范围:128~191
* C类地址:网络id24位,以110开头,第一个字节范围:192~223
* D类地址:以1110开头,第一个字节范围为224~239,多播地址
* E类地址:以1111开头,保留地址

保留地址:

A类:10.0.0.0 - 10.255.255.255
B类:172.16.0.0 - 172.31.255.255
C类:192.168.0.0 - 192.168.255.255

> IPv6 : 采用128bit,首部固定部分为40字节

## ARP

网络层协议

ARP:Address Resolution Protocol,地址解析协议,完成了IP地址与物理地址的映射

物理地址是数据链路层和物理层使用的地址,
IP地址是网络层和以上各层使用的地址,是一种逻辑地址.
其中ARP协议用于IP地址与物理地址的对应

## ICMP

ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会.它封装在 IP 数据报中,但是不属于高层协议
ICMP 报文分为差错报告报文和询问报文.
ping 是 ICMP 的一个重要应用,主要用来测试两台主机之间的连通性.
ping 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报.

### Traceroute

Traceroute 是 ICMP 的另一个应用,用来跟踪一个分组从源点到终点的路径

1. 源主机向目的主机发送一连串的 IP 数据报.第一个数据报 P1 的生存时间 TTL 设置为 1,但 P1 到达路径上的第一个路由器 R1 时,R1 收下它并把 TTL 减 1,此时 TTL 等于 0,R1 就把 P1 丢弃,并向源主机发送一个 ICMP 时间超过差错报告报文;
2. 源主机接着发送第二个数据报 P2,并把 TTL 设置为 2. P2 先到达 R1,R1 收下后把 TTL 减 1 再转发给 R2,R2 收下后也把 TTL 减 1,由于此时 TTL 等于 0,R2 就丢弃 P2,并向源主机发送一个 ICMP 时间超过差错报文.
3. 不断执行这样的步骤,直到最后一个数据报刚刚到达目的主机,主机不转发数据报,也不把 TTL 值减 1.但是因为数据报封装的是无法交付的 UDP,因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文.
4. 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间.


## 路由器


路由选择和分组转发

内部网关协议 IGP（Interior Gateway Protocol)：在 AS 内部使用,如 RIP 和 OSPF.
外部网关协议 EGP（External Gateway Protocol)：在 AS 之间使用,如 BGP.

RIP(路由信息协议)
OSPF(开放最短路径优先)
BGP:Border Gateway Protocol(边界网关协议)

> AS:自治系统

<!--
TCP三次握手数据丢失了怎么办?那如果后面又找到了呢?
DHCP如何实现分配IP的; 发现阶段(DHCP客户端在网络中广播发送DHCP DISCOVER请求报文,发现DHCP服务器,请求IP地址租约),提供阶段(DHCP服务器通过DHCP OFFER报文向DHCP客户端提供IP地址预分配),选择阶段(DHCP客户端通过DHCP REQUEST报文确认选择第一个DHCP服务器为它提供IP地址自动分配服务)和确认阶段(被选择的DHCP服务器通过DHCP ACK报文把在DHCP OFFER报文中准备的IP地址租约给对应DHCP客户端).
OSI七层模型,每层都说下自己的理解和知道的,说的越多越好;
TCP和UDP各自的优势,知道哪些使用UDP协议的成功案例;
TCP和UDP各用了底层什么协议;
单个UDP报文最大容量;
单个TCP报文最大容量;
TCP报头格式,UDP报头格式;
Server遭遇SYN Flood应当怎么处理;
拆包和粘包的问题,如何解决,如果我们的包没有固定长度的话,我们的应用程序应该如何解决;
数据链路层是做什么的?
网络模型的分层,IP和Mac地址在那个层,TCP和HTTP分别在那个层;
TCP的同传,拆包与组装包是什么意思;
两个不同ip地址的计算机之间如何通信;
-->

**在浏览器输入一个网址发生了什么**

1. 浏览器查找该域名的 IP 地址(用ARP协议获取物理地址和DNS协议获取网络地址,即IP地址)
2. 浏览器根据解析得到的IP地址向 web 服务器发送请求建立连接,发起三次握手
3. 请求建立,客户端发起 HTTP 请求.(用到TCP,IP,以太网协议报头)
4. 服务器收到请求,根据路径参数映射到特定的请求处理器进行处理
5. 服务器将处理结果及相应的视图返回给浏览器.(服务器返回一个 HTTP 响应,如果返回状态码304,浏览器可以直接使用之前缓存的资源.对于内容响应,浏览器需要进行响应解码,渲染显示.)
6. 浏览器对该响应进行解码,渲染显示.( 在浏览器没有完整接受全部HTML文档时,(打开网页,网页显示用到了表示层的HTML协议)它就已经开始显示这个页面了,如果是个静态的页面,那到此就基本结束了.如果是是动态的,那么在浏览器显示HTML时,会获取嵌入在HTML中的对象,浏览器会发送获取请求来重新获得这些文件.这些请求都要经历一个和HTML读取类似的过程. 对于静态的页面内容,浏览器通常会进行缓存,而对于动态的内容,浏览器通常不会进行缓存)
7. 完成后,浏览器发送异步请求(页面显示完成后客户端仍与服务器端保持着联系. 它会持续与服务器保持联系来及时更新一些页面信息.在浏览器中执行的 JavaScript代码会给服务器发送异步请求.这个异步请求发送给特定的地址,它是一个按照程式构造的获取或发送请求.)

> 此过程用到的协议:
> 应用层使用了HTTP协议进行超文本传输,对于服务器后台处理应该有telnet远程调用协议响应用户,DNS协议获取网络地址,即IP地址;
> 另外必然用到了传输层的TCP和网络层的IP协议;网络层ARP协议获取物理地址;ICMP协议控制信息的传递.

**对称加密与非对称加密**

对称密钥加密是指加密和解密使用同一个密钥的方式,这种方式存在的最大问题就是密钥发送问题,即如何安全地将密钥发给对方;
非对称加密是指使用一对非对称密钥,即公钥和私钥,公钥可以随意发布,但私钥只有自己知道.发送密文的一方使用对方的公钥进行加密处理,对方接收到加密信息后,使用自己的私钥进行解密.

由于非对称加密的方式不需要发送用来解密的私钥,所以可以保证安全性;但是和对称加密比起来,它非常的慢,所以我们还是要用对称加密来传送消息,但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去.

**DDoS攻击**

分布式拒绝服务攻击,三次握手的最后一次不进行(不发送确认数据)从而使服务端一直处于等待的状态.
无法彻底解决,预防方式有以下:
* 限制同时打开SYN半链接的数目
* 缩短SYN半链接的Time out 时间
* 关闭不必要的服务

**XSS攻击**

cross site script,跨站脚本攻击
过于信任客户端提交的数据

反射性XSS攻击:攻击者注入的数据反映在响应中
持久性XSS攻击:XSS攻击代码存储在网站数据库

# 网络接口层



# 参考

[计算机网络体系结构综述(上)](https://blog.csdn.net/justloveyou_/article/details/69611328)