---
title: 代理模式
date: 2017-11-01
tags:
- 设计模式
---

当对某对象无法访问或者访问有困难时候,可以通过代理的方式进行访问
代理模式也是这样的一个过程,另外,代理的过程中还能对功能进行增强
代理类和委托类要实现相同的接口，因为代理真正调用的还是委托类的方法.

按照代理的创建时期，代理类可以分为两种： 
静态：由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了。
动态：在程序运行时运用反射机制动态创建而成。
 
抽象类,具体类,代理类

关键点在代理类的设计和实现.


仍然是打印日志的例子, 想要在打印日志前后各执行一部分操作
根据开闭原则,直接修改日志打印类是不推荐的,这也就创造了一种访问有困难的一种情形


创建一个代理类LogPrinterProxy,和LogPrinter类一样,继承或实现Printer类,
并拥有一个LogPrinter的引用

功能的增强并不是使用代理模式的首要考虑点,这也是和装饰者模式的一大区别

实际开发中,代理模式也有多个种类:

* 远程代理(Remote Proxy):为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador).
* 虚拟代理(Virtual Proxy):如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建.
* 保护代理(Protect Proxy):控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限.
* 缓冲代理(Cache Proxy):为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果.
* 智能引用代理(Smart Reference Proxy):当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等.


# 参照

[静态代理VS动态代理](http://blog.csdn.net/hejingyuan6/article/details/36203505)