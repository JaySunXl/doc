---
title: 源码解读-ThreadLocal
date: 2018-03-14
tags:
- Java
---
<!-- TOC -->

- [结构](#结构)
- [方法](#方法)
- [内存溢出](#内存溢出)
- [](#)

<!-- /TOC -->

# 结构

```Java
static class ThreadLocalMap {
    static class Entry extends WeakReference<ThreadLocal<?>> {
        ....;
    }
}
```

**ThreadLocal**

不是为解决多线程共享变量而生,它为每一个使用ThreadLocal对象的线程都创建一个单独的变量副本,减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度
通常被`private static`修饰.
ThreadLocal本身不存储值,而是作为一个key,去ThreadLocalMap中去存储的具体内容,存储容器是ThreadLocalMap中的entry.

**ThreadLocalMap**

基于hash算法的,其entry为弱引用类型的map.
默认ThreadLocalMap初始化了16个Entry,每个Entry对象存放一个ThreadLocal对象为key的键值对.

**Thread**

```Java
ThreadLocal.ThreadLocalMap threadLocals = null;
```
一个Thread中只有一个ThreadLocalMap,
一个ThreadLocalMap中可以有多个ThreadLocal对象,其中一个ThreadLocal对象对应一个ThreadLocalMap中的一个Entry
(也就是说:一个Thread可以依附有多个ThreadLocal对象)

![](https://raw.githubusercontent.com/LuVx21/hexo/master/source/_posts/99.img/threadlocal.jpg)

一个线程的所有局部变量都是存在同一个map对象中.


在Thread对象中,threadLocals为空,当通过ThreadLocal变量调用`get(),set()`方法时,会对Thread类中的threadLocals进行初始化,

以当前ThreadLocal变量为key,以要保存内容为value,存到ThreadLocalMap中


# 方法

* get()：返回此线程局部变量的当前线程副本中的值.
* initialValue()：返回此线程局部变量的当前线程的"初始值",通常用于重写.
* remove()：移除此线程局部变量当前线程的值.
* set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值

需要注意的是在没有set前调用get会抛出空指针异常,除非重写initialValue方法.

```Java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);// 根据线程获取线程用于的map
    if (map != null)
        map.set(this, value);// 以ThreadLocal对象为key存入map
    else
        createMap(t, value);
}
```
```Java
private void set(ThreadLocal<?> key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1);

    for (Entry e = tab[i];
            e != null;
            e = tab[i = nextIndex(i, len)]) {
        ThreadLocal<?> k = e.get();

        if (k == key) {
            e.value = value;
            return;
        }

        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    tab[i] = new Entry(key, value);
    int sz = ++size;
    if (!cleanSomeSlots(i, sz) && sz >= threshold)// 进行回收内存
        rehash();
}
```
```Java
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();// 未set即get
}
```

# 内存溢出

线程退出时会置空`threadLocals`属性,但若是使用线程池时不销毁线程,那么map中的对象就不会被释放,造成OOM.

ThreadLocalMap中使用ThreadLocal的弱引用作为key,GC时这个弱引用的对象会被回收,从而出现key为null的entry.如果线程不退出,这个value无法被访问到,也不会被GC,白白占用空间却不起作用,此时就有可能造成OOM.

实际上,get(),set(),remove()方法中存在清除所有key为null的value,

**为什么使用弱引用而不是强引用**

线程不结束,ThreadLocalMap就会一直存在,因此推荐在使用完ThreadLocal后调用其remove()方法.

#




WeakReference

[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)