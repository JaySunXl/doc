---
title: 源码解读-ThreadLocal
date: 2018-03-14
tags:
- Java
---
<!-- TOC -->

- [结构](#结构)
- [方法](#方法)
- [内存溢出](#内存溢出)

<!-- /TOC -->

# 结构

```Java
static class ThreadLocalMap {
    static class Entry extends WeakReference<ThreadLocal<?>> {
        ....;
    }
}
```

**ThreadLocal**

不是为解决多线程共享变量而生,它为每一个使用ThreadLocal对象的线程都创建一个单独的变量副本.
通常被`private static`修饰.

**ThreadLocalMap**

基于hash算法的,其entry为弱引用类型的map.
默认ThreadLocalMap初始化了16个Entry,每个Entry对象存放一个ThreadLocal对象为key的键值对.

**Thread**

```Java
ThreadLocal.ThreadLocalMap threadLocals = null;
```
一个Thread中只有一个ThreadLocalMap,
一个ThreadLocalMap中可以有多个ThreadLocal对象,其中一个ThreadLocal对象对应一个ThreadLocalMap中的一个Entry
(也就是说:一个Thread可以依附有多个ThreadLocal对象)

![](https://raw.githubusercontent.com/LuVx21/hexo/master/source/_posts/99.img/threadlocal.jpg)

一个线程的所有局部变量都是存在同一个map对象中.


# 方法

* get()：返回此线程局部变量的当前线程副本中的值。
* initialValue()：返回此线程局部变量的当前线程的“初始值”。
* remove()：移除此线程局部变量当前线程的值。
* set(T value)：将此线程局部变量的当前线程副本中的值设置为指定值

```Java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);// 根据线程获取线程用于的map
    if (map != null)
        map.set(this, value);// 以ThreadLocal对象为key存入map
    else
        createMap(t, value);
}
```
```Java
private void set(ThreadLocal<?> key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1);

    for (Entry e = tab[i];
            e != null;
            e = tab[i = nextIndex(i, len)]) {
        ThreadLocal<?> k = e.get();

        if (k == key) {
            e.value = value;
            return;
        }

        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    tab[i] = new Entry(key, value);
    int sz = ++size;
    if (!cleanSomeSlots(i, sz) && sz >= threshold)// 进行回收内存
        rehash();
}
```
```Java
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
```

# 内存溢出

线程退出时会置空`threadLocals`属性,但若是使用线程池时不销毁线程,那么map中的对象就不会被释放,造成OOM.

WeakReference

[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)