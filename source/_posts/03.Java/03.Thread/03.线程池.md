---
title: 多线程: 线程池
date: 2018-06-29
tags:
- Java
---
<!-- TOC -->

- [作用](#作用)
- [创建](#创建)
- [方法](#方法)
- [原理](#原理)
- [Q&A](#qa)
- [参考](#参考)

<!-- /TOC -->

# 作用

* 频繁的创建和销毁会影响性能
* 复用线程, 线程使用完后不是销毁而是放回线程池, 意义同数据库连接池
* 将线程的创建, 执行完全分开

# 创建

![](https: //raw.githubusercontent.com/LuVx21/hexo/master/source/_posts/99.img/Executors.png)

1. CachedThreadPool: 1个任务创建1个线程
2. FixedThreadPool: 固定大小的线程池
3. SingleThreadExecutor: 大小为1的FixedThreadPool

```Java
// 该方法返回一个固定线程数量的线程池
public static ExecutorService newFixedThreadPool()
// 该方法返回一个只有一个线程的线程池
public static ExecutorService newSingleThreadExecutor()
// 返回一个可以根据实际情况调整线程数量的线程池
public static ExecutorService newCachedThreadPool()
// 该方法和newSingleThreadExecutor的区别是给定了时间执行某任务的功能, 可以进行定时执行等
public static ScheduledExecutorService newSingleThreadScheduledExecutor()
// 可以指定线程数量
public static ScheduledExecutorService newScheduledThreadPool()
```

使用例:
```java
ExecutorService executorService = Executors.newCachedThreadPool();
for (int i = 0; i < 3; i++) {
    executorService.execute(new ThreadCase());
}
// Future<?> future = executorService.submit();
// future.cancel(true);
executorService.shutdown();
```

线程池不推荐使用Executors去创建, 而是使用`ThreadPoolExecutor`创建,

```Java
// 1. corePoolSize 核心线程池大小;
// 2. maximumPoolSize 线程池最大容量大小;
// 3. keepAliveTime 线程池空闲时, 线程存活的时间;
// 4. TimeUnit 时间单位;
// 5. workQueue 任务队列;
// 6. ThreadFactory 线程工厂;
// 7. RejectedExecutionHandler 线程拒绝策略;
public ThreadPoolExecutor(int corePoolSize,  int maximumPoolSize,  long keepAliveTime,
TimeUnit unit,  BlockingQueue<Runnable> workQueue,  ThreadFactory threadFactory,  RejectedExecutionHandler handler)
```

**核心线程数和最大线程数**
默认情况下, 线程池创建后, 其中没有线程, 除非是调用了`prestartAllCoreThreads`(启动所有核心线程)或`prestartCoreThread`(启动一个核心线程)方法,
当需要执行任务时才会创建线程, 当数量达到`corePoolSize`时, 将任务加入阻塞队列, 当队列满时, 会继续创建线程执行任务知道数量到达`maximumPoolSize`

由于`submit()`不输出异常信息, 因此推荐使用下面的方式:
* 使用execute()代替submit()
* 使用Future, 原因同实现`Callable`创建线程

> execute()方法用于提交不需要返回值的任务, 无法判断任务是否被线程池执行成功
> submit()方法用于提交需要返回值的任务, 使用Future的get()方法来获取返回值, get()方法会阻塞当前线程直到任务完成

# 方法

Executors类

```java
// 停止接受新任务, 平滑关闭线程(线程结束后关闭)
public void shutdown()
// like关闭所有线程(不会等待线程执行结束, 此时和interrupt方法作用相同
public List<Runnable> shutdownNow()
```

# 原理

此时再返回分析为什么不推荐使用最初的3种创建方式:

```Java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads,  nThreads,
                                    0L,  TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>());
}
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0,  Integer.MAX_VALUE,
                                    60L,  TimeUnit.SECONDS,
                                    new SynchronousQueue<Runnable>());
}
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1,  1,
                                0L,  TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

观察可依次总结出:

1. newFixedThreadPool: 核心线程数没有限制, 没有超时机制, 除非线程池关闭, 核心线程才会被回收
2. newCachedThreadPool: 空闲线程超过60秒就会被回收, 最大线程可为最大int型
3. newSingleThreadExecutor: 只有一个核心线程, 没有超时机制, 不处理并发

> 线程池不允许使用 Executors 去创建, 而是通过 ThreadPoolExecutor 的方式, 这样的处理方式让写的同学更加明确线程池的运行规则, 规避资源耗尽的风险.
> 说明: Executors 返回的线程池对象的弊端如下:
>
> 1) `FixedThreadPool` 和 `SingleThreadPool`:
> 允许的请求队列长度为 Integer.MAX_VALUE, 可能会堆积大量的请求, 从而导致 OOM.
> 2) `CachedThreadPool` 和 `ScheduledThreadPool`:
> 允许的创建线程数量为 Integer.MAX_VALUE, 可能会创建大量的线程, 从而导致 OOM.

摘自[阿里巴巴Java开发手册](https: //github.com/alibaba/p3c)

线程池处理流程:

![](https: //raw.githubusercontent.com/LuVx21/hexo/master/source/_posts/99.img/threadpool.png)

1. 检测核心线程数是否达到corePoolSize, 没有则创建新线程, 否则进入阻塞队列
2. 检测阻塞队列是否已满, 没有则直接放入, 否则进入下一步
3. 检测线程数是否达到线程池最大容量大小maximumPoolSize, 没有则创建新线程, 否则根据饱和策略处理

> core线程池满? -> 等待队列满? -> 整个线程池满? -> 饱和策略

上面这个过程是在`execute()`方法中体现[Link](https: //github.com/lambdalab-mirror/jdk8u-jdk/blob/master/src/share/classes/java/util/concurrent/ThreadPoolExecutor.java#L1332):
```Java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
        * Proceed in 3 steps:
        *
        * 1. If fewer than corePoolSize threads are running,  try to
        * start a new thread with the given command as its first
        * task.  The call to addWorker atomically checks runState and
        * workerCount,  and so prevents false alarms that would add
        * threads when it shouldn't,  by returning false.
        *
        * 2. If a task can be successfully queued,  then we still need
        * to double-check whether we should have added a thread
        * (because existing ones died since last checking) or that
        * the pool shut down since entry into this method. So we
        * recheck state and if necessary roll back the enqueuing if
        * stopped,  or start a new thread if there are none.
        *
        * 3. If we cannot queue task,  then we try to add a new
        * thread.  If it fails,  we know we are shut down or saturated
        * and so reject the task.
        */
    int c = ctl.get();
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command,  true))
            return;
        c = ctl.get();
    }
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null,  false);
    }
    else if (!addWorker(command,  false))
        reject(command);
}
```

**线程池状态**

```Java
// 前线程池的状态, 它是一个volatile变量用来保证线程之间的可见性
volatile int runState;
// 线程池创建后处于运行状态
static final int RUNNING    = 0;
// 执行shutdown()方法
static final int SHUTDOWN   = 1;
// 执行了shutdownNow()
static final int STOP       = 2;
// 处于SHUTDOWN或STOP状态, 且所有线程已经销毁, 任务已经执行结束后进入终止状态
static final int TERMINATED = 3;
```


**饱和策略**

使用Executors创建线程池时, 不会传入饱和策略这个参数, 因此会使用默认的策略.
常用饱和策略:

* 直接丢弃任务: AbortPolicy, 会抛出`RejectedExecutionException`异常
* 调用者线程处理: CallerRunsPolicy
* 丢弃队列中的最近任务, 执行当前任务: DiscardPolicy, DiscardOldestPolicy: 不会抛出异常

# Q&A

**如何根据CPU的核数来设计线程大小**

计算密集型

无需设置过大的线程池工作队列, 工作队列长度 = CPU核心数 || CPU核心数+1

IO密集型

适当加大工作队列长度

> [阅读](https://blog.csdn.net/lc0817/article/details/50706720)

# 参考

[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)
