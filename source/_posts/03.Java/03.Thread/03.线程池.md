---
title: 多线程: 线程池
date: 2018-06-29
tags:
- Java
---
<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [作用](#作用)
- [Usage](#usage)
- [原理](#原理)
    - [Executor](#executor)
    - [ExecutorService](#executorservice)
    - [AbstractExecutorService](#abstractexecutorservice)
    - [ThreadPoolExecutor](#threadpoolexecutor)
    - [工作流程](#工作流程)
    - [Worker](#worker)
- [线程池状态](#线程池状态)
- [任务队列](#任务队列)
    - [队列的实现](#队列的实现)
- [Q&A](#qa)
- [参考](#参考)

<!-- /TOC -->
</details>

## 作用

* 频繁的创建和销毁会影响性能
* 复用线程, 线程使用完后不是销毁而是放回线程池, 意义同数据库连接池
* 将线程的创建, 执行完全分开

## Usage

以下为`Executors`工具类提供的静态方法用于创建线程池: 

```Java
// 该方法返回一个只有一个线程的线程池
public static ExecutorService newSingleThreadExecutor()
// 该方法返回一个固定线程数量的线程池
public static ExecutorService newFixedThreadPool(int nThreads)
// 返回一个可以根据实际情况调整线程数量的线程池
public static ExecutorService newCachedThreadPool()
// 该方法和newSingleThreadExecutor的区别是给定了时间执行某任务的功能, 可以进行定时执行等
public static ScheduledExecutorService newSingleThreadScheduledExecutor()
// 可以指定线程数量
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
```
使用以上方法, 能够创建以下形式的线程池:

1. SingleThreadExecutor: 大小为1的FixedThreadPool
2. FixedThreadPool: 固定大小的线程池
3. CachedThreadPool: 1个任务创建1个线程
4. 对应1,2的`Scheduled`前缀的线程池

使用例:
```java
ExecutorService executorService = Executors.newCachedThreadPool();
for (int i = 0; i < 3; i++) {
    executorService.execute(new ThreadCase());
}
// Future<?> future = executorService.submit();
// future.cancel(true);
executorService.shutdown();
```

线程池不推荐使用`Executors`的静态方法去创建, 而是使用实现类`ThreadPoolExecutor`的构造方法创建

## 原理
![](https://dev.tencent.com/u/LuVx21/p/img/git/raw/master/Executors.png)

### Executor
接口, 仅有一个方法
```Java
// 
void execute(Runnable command);
```

### ExecutorService

```Java
// 停止接受新任务, 平滑关闭线程(线程结束后关闭)
void shutdown()
// like关闭所有线程(不会等待线程执行结束, 此时和interrupt方法作用相同
List<Runnable> shutdownNow()
// 线程池是否关闭 
boolean isShutdown();
// 阻塞等待所有任务全部结束或超时
boolean awaitTermination(long timeout, TimeUnit unit)
boolean isTerminated();
// 提交任务
<T> Future<T> submit(Callable<T> task);
<T> Future<T> submit(Runnable task, T result);
Future<?> submit(Runnable task);
// 
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
<T> T invokeAny(Collection<? extends Callable<T>> tasks)
<T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
```

由于`submit()`不输出异常信息, 因此推荐使用下面的方式:
* 使用`execute()`代替`submit()`
* 使用Future, 原因同实现`Callable`创建线程

> execute()方法用于提交不需要返回值的任务, 无法判断任务是否被线程池执行成功
> submit()方法用于提交需要返回值的任务, 使用Future的get()方法来获取返回值, get()方法会阻塞当前线程直到任务完成

### AbstractExecutorService

实现`ExecutorService`, 重写了其方法

```Java
public <T> Future<T> submit(Callable<T> task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture<T> ftask = newTaskFor(task);
    execute(ftask);
    return ftask;
}
protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
    return new FutureTask<T>(callable);
}
```

### ThreadPoolExecutor

实现了`execute`方法

提供了4个构造方法,, 实际上内部都是使用的同一个
```Java
// 1. corePoolSize 核心线程池大小
// 2. maximumPoolSize 线程池最大容量大小
// 3. keepAliveTime 线程数目大于核心线程数时, 结束多余的线程锁存活的时间
// 4. TimeUnit 时间单位
// 5. workQueue 任务队列, 仅保持由 execute 方法提交的 Runnable 任务
// 6. ThreadFactory 线程工厂
// 7. RejectedExecutionHandler 线程拒绝策略
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,
TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)
```

> Guava对线程池有不错的支持和扩展, 如:
> `ThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat("demo-pool-%d").build();`
> `ListeningExecutorService service1 = MoreExecutors.listeningDecorator(service);`

**核心线程数和最大线程数**
默认情况下, 线程池创建后, 其中没有线程, 除非是调用了`prestartAllCoreThreads`(启动所有核心线程)或`prestartCoreThread`(启动一个核心线程)方法,

当需要执行任务时才会创建线程, 当数量达到`corePoolSize`时, 将任务加入阻塞队列, 当队列满时, 会继续创建线程执行任务直到数量到达`maximumPoolSize`

### 工作流程

此时再返回分析为什么不推荐使用最初的3种创建方式:

```Java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>());
}
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue<Runnable>());
}
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

观察可依次总结出:

1. newFixedThreadPool: 核心线程数没有限制, 没有超时机制, 除非线程池关闭, 核心线程才会被回收
2. newCachedThreadPool: 空闲线程超过60秒就会被回收, 最大线程可为最大int型
3. newSingleThreadExecutor: 只有一个核心线程, 没有超时机制, 不处理并发

> 线程池不允许使用 `Executors` 去创建, 而是通过 `ThreadPoolExecutor` 的方式, 这样的处理方式让写的同学更加明确线程池的运行规则, 规避资源耗尽的风险.
> 说明: `Executors` 返回的线程池对象的弊端如下:
>
> 1) `FixedThreadPool` 和 `SingleThreadPool`:
> 允许的请求队列长度为 Integer.MAX_VALUE, 可能会堆积大量的请求, 从而导致 OOM.
> 2) `CachedThreadPool` 和 `ScheduledThreadPool`:
> 允许的创建线程数量为 Integer.MAX_VALUE, 可能会创建大量的线程, 从而导致 OOM.

摘自[阿里巴巴Java开发手册](https://github.com/alibaba/p3c)

线程池处理流程:

![](https://dev.tencent.com/u/LuVx21/p/img/git/raw/master/threadpool.png)

1. 检测核心线程数是否达到corePoolSize, 没有则创建新线程, 否则进入阻塞队列
2. 检测阻塞队列是否已满, 没有则直接放入, 否则进入下一步
3. 检测线程数是否达到线程池最大容量大小maximumPoolSize, 没有则创建新线程, 否则根据饱和策略处理

> core线程池满? -> 等待队列满? -> 整个线程池满? -> 饱和策略

上面这个过程在`ThreadPoolExecutor`类的`execute()`方法中体现

```Java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
        * Proceed in 3 steps:
        *
        * 1. If fewer than corePoolSize threads are running, try to
        * start a new thread with the given command as its first
        * task.  The call to addWorker atomically checks runState and
        * workerCount, and so prevents false alarms that would add
        * threads when it shouldn't, by returning false.
        *
        * 2. If a task can be successfully queued, then we still need
        * to double-check whether we should have added a thread
        * (because existing ones died since last checking) or that
        * the pool shut down since entry into this method. So we
        * recheck state and if necessary roll back the enqueuing if
        * stopped, or start a new thread if there are none.
        *
        * 3. If we cannot queue task, then we try to add a new
        * thread.  If it fails, we know we are shut down or saturated
        * and so reject the task.
        */
    int c = ctl.get();
    if (workerCountOf(c) < corePoolSize) {// 活动线程数小于核心线程数
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }// 不小于核心线程数
    // 线程池状态为运行,加入任务
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))// 线程池不处于运行状态
            reject(command);// 拒绝任务
        else if (workerCountOf(recheck) == 0)// 活动线程数为0, 创建线程
            addWorker(null, false);
    }
    else if (!addWorker(command, false))// 不处于运行状态或添加任务失败(队列满)
        reject(command);
}
```

```Java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
                firstTask == null &&
                ! workQueue.isEmpty()))
            return false;

        for (;;) {
            int wc = workerCountOf(c);
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());

                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

addWorker -> runWorker -> 
[源码](https://github.com/lambdalab-mirror/jdk8u-jdk/blob/master/src/share/classes/java/util/concurrent/ThreadPoolExecutor.java#L1332):

### Worker

```Java
private final class Worker extends AbstractQueuedSynchronizer
        implements Runnable {
}
```

使用独占锁来表示线程是否正在执行任务
实现的是不可重入锁

## 线程池状态

```Java
// 线程池的状态, 它是一个volatile变量用来保证线程之间的可见性
volatile int runState;
private static final int COUNT_BITS = Integer.SIZE - 3;// 32 - 3
// 最大活动线程数
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;
// 线程池创建后处于运行状态
private static final int RUNNING    = -1 << COUNT_BITS;
// 执行shutdown()方法
private static final int SHUTDOWN   =  0 << COUNT_BITS;
// 执行了shutdownNow()
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
// 执行了terminated()
// 处于SHUTDOWN或STOP状态, 且所有线程已经销毁, 任务已经执行结束后进入终止状态
private static final int TERMINATED =  3 << COUNT_BITS;
```

上述6个变量的二进制为:
|值|移位|高3位|
|:---|:---|:---|
|CAPACITY|11111111111111111111111111111||
|-1|11100000000000000000000000000000|111|
|0|0|000|
|1|00100000000000000000000000000000|001|
|2|01000000000000000000000000000000|010|
|3|01100000000000000000000000000000|011|

高3位表示线程池5种状态, 低29位表示活动线程数

## 任务队列

当线程池中的线程数大于核心线程数时, 再有新任务被提交则会加入队列, 而不是创建新的线程

当线程数量已经达到最大值时, 针对新提交的任务, 会根据饱和策略处理这些任务

使用`Executors`创建线程池时, 不会传入饱和策略这个参数, 因此会使用默认的策略.

常用饱和策略:

* 直接丢弃任务: AbortPolicy, 会抛出`RejectedExecutionException`异常
* 调用者线程处理: CallerRunsPolicy
* DiscardPolicy: 删除不能执行的任务
* DiscardOldestPolicy: 丢弃队列中的队头任务, 执行当前任务, 不会抛出异常

### 队列的实现

元素唯一的`LinkedBlockingQueue`:
```Java
class UniqueLinkedBlockingQueue<E> extends LinkedBlockingQueue<E> {
    private static final long          serialVersionUID = 6523405086129214113L;
    private final        ReentrantLock putLock          = new ReentrantLock();

    @Override
    public void put(E e) throws InterruptedException {
        putLock.lock();
        try {
            if (!contains(e)) {
                super.put(e);
            }
        } finally {
            putLock.unlock();
        }
    }
}
```

## Q&A

**如何根据CPU的核数来设计线程大小**

计算密集型

无需设置过大的线程池工作队列, 工作队列长度 = CPU核心数 || CPU核心数+1

IO密集型

适当加大工作队列长度

> [阅读](https://blog.csdn.net/lc0817/article/details/50706720)


最佳线程数目 = ((线程等待时间 + 线程CPU时间) / 线程CPU时间) * CPU数目
最佳线程数目 = (线程等待时间与线程CPU时间之比 + 1) * CPU数目

## 参考

池在哪里?是什么数据结构?工作流程是怎样的?



[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)
