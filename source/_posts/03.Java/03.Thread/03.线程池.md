---
title: 线程通信
date:
tags:
- Java
---
<!-- TOC -->

- [Q&A](#qa)
- [参考](#参考)

<!-- /TOC -->

CachedThreadPool：1个任务创建1个线程；
FixedThreadPool：固定大小的线程池；
SingleThreadExecutor：大小为 1 的 FixedThreadPool
```java
ExecutorService executorService = Executors.newCachedThreadPool();
for (int i = 0; i < 3; i++) {
    executorService.execute(new ThreadCase());
}
// Future<?> future = executorService.submit();
// future.cancel(true);
executorService.shutdown();
```

# 线程池

为了避免系统频繁的创建和销毁线程,将创建的线程进行复用,意义同数据库连接池.
线程使用完后不是销毁而是放回线程池

在java中怎么创建一个线程池
（Executors,或者new ThreadPoolExecutor（））,线程池可以解决什么问题（减少了线程创建销毁的时间）,可以继续问一下一个线程被提交到线程池会做些什么判断（core线程池满？->等待队列满？->整个线程池满？->饱和策略）
Executors类
```java
// 该方法返回一个固定线程数量的线程池
public static ExecutorService newFixedThreadPool()
// 该方法返回一个只有一个线程的线程池
public static ExecutorService newSingleThreadExecutor()
// 返回一个可以根据实际情况调整线程数量的线程池
public static ExecutorService newCachedThreadPool()
// 该方法和newSingleThreadExecutor的区别是给定了时间执行某任务的功能,可以进行定时执行等
public static ScheduledExecutorService newSingleThreadScheduledExecutor()
// 可以指定线程数量
public static ScheduledExecutorService newScheduledThreadPool()
// 
shutdown()
// 
shutdownNow()
```

线程池不推荐使用Executors去创建,而是使用`ThreadPoolExecutor`创建,

```Java
// 1. corePoolSize 核心线程池大小;
// 2. maximumPoolSize 线程池最大容量大小;
// 3. keepAliveTime 线程池空闲时,线程存活的时间;
// 4. TimeUnit 时间单位;
// 5. BlockingQueue任务队列;
// 6. ThreadFactory 线程工厂;
// 7. RejectedExecutionHandler 线程拒绝策略;
ExecutorService executorService = new ThreadPoolExecutor(1,2,3,4,5,6,7)
```

由于`submit()`不输出异常信息,因此推荐使用下面的方式:
* 使用execute()代替submit()
* 使用Future,原因同实现`Callable`创建线程

> execute()方法用于提交不需要返回值的任务,无法判断任务是否被线程池执行成功
> submit()方法用于提交需要返回值的任务,使用Future的get()方法来获取返回值,get()方法会阻塞当前线程直到任务完成

# Q&A

# 参考


[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)