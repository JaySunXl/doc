---
title: 多线程:线程池
date: 2018-06-29
tags:
- Java
---
<!-- TOC -->

- [作用](#作用)
- [创建](#创建)
- [方法](#方法)
- [原理](#原理)
- [Q&A](#qa)
- [参考](#参考)

<!-- /TOC -->

# 作用

* 频繁的创建和销毁会影响性能
* 复用线程,线程使用完后不是销毁而是放回线程池,意义同数据库连接池
* 将线程的创建,执行完全分开

# 创建

* CachedThreadPool: 1个任务创建1个线程
* FixedThreadPool: 固定大小的线程池
* SingleThreadExecutor: 大小为1的FixedThreadPool

```Java
// 该方法返回一个固定线程数量的线程池
public static ExecutorService newFixedThreadPool()
// 该方法返回一个只有一个线程的线程池
public static ExecutorService newSingleThreadExecutor()
// 返回一个可以根据实际情况调整线程数量的线程池
public static ExecutorService newCachedThreadPool()
// 该方法和newSingleThreadExecutor的区别是给定了时间执行某任务的功能,可以进行定时执行等
public static ScheduledExecutorService newSingleThreadScheduledExecutor()
// 可以指定线程数量
public static ScheduledExecutorService newScheduledThreadPool()
```

使用例:
```java
ExecutorService executorService = Executors.newCachedThreadPool();
for (int i = 0; i < 3; i++) {
    executorService.execute(new ThreadCase());
}
// Future<?> future = executorService.submit();
// future.cancel(true);
executorService.shutdown();
```

线程池不推荐使用Executors去创建,而是使用`ThreadPoolExecutor`创建,

```Java
// 1. corePoolSize 核心线程池大小;
// 2. maximumPoolSize 线程池最大容量大小;
// 3. keepAliveTime 线程池空闲时,线程存活的时间;
// 4. TimeUnit 时间单位;
// 5. workQueue 任务队列;
// 6. ThreadFactory 线程工厂;
// 7. RejectedExecutionHandler 线程拒绝策略;
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,
TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 
```

由于`submit()`不输出异常信息,因此推荐使用下面的方式:
* 使用execute()代替submit()
* 使用Future,原因同实现`Callable`创建线程

> execute()方法用于提交不需要返回值的任务,无法判断任务是否被线程池执行成功
> submit()方法用于提交需要返回值的任务,使用Future的get()方法来获取返回值,get()方法会阻塞当前线程直到任务完成

# 方法

Executors类

```java
// 停止接受新任务,平滑关闭线程(线程结束后关闭)
public void shutdown()
// like关闭所有线程(不会等待线程执行结束,此时和interrupt方法作用相同
public List<Runnable> shutdownNow()
```

# 原理

![](https://raw.githubusercontent.com/LuVx21/hexo/master/source/_posts/99.img/threadpool.png)

1. 检测核心线程数是否达到corePoolSize,没有则创建新线程,否则进入阻塞队列
2. 检测阻塞队列是否已满,没有则直接放入,否则进入下一步
3. 检测线程数是否达到线程池最大容量大小maximumPoolSize,没有则创建新线程,否则根据饱和策略处理

> core线程池满? -> 等待队列满? -> 整个线程池满? -> 饱和策略

常用饱和策略:
* 直接丢弃任务
* 调用者线程处理
* 丢弃队列中的最近任务,执行当前任务


# Q&A



# 参考


[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)