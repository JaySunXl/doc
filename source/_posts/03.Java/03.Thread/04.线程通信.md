---
title: 线程通信
date:
tags:
- Java
---
<!-- TOC -->

- [wait/notify通信机制](#waitnotify通信机制)
- [信号量机制](#信号量机制)
- [线程计数器](#线程计数器)
    - [CountDownLatch](#countdownlatch)
    - [CyclicBarrier](#cyclicbarrier)
- [Q&A](#qa)
- [参考](#参考)

<!-- /TOC -->

# wait/notify通信机制

一个线程在使用的同步方法中时, 可能根据问题的需要, 必须使用wait() (挂起)方法使本线程等待, 暂时让出CPU的使用权, 并允许其它线程使用这个同步方法.
其它线程如果在使用这个同步方法时不需要等待, 那么它用完这个同步方法的同时,
应当执行notify(), notifyAll()(恢复)方法通知所有的由于使用这个同步方法而处于等待的线程结束等待.
这就是wait/notify线程间通信机制.

wait()/notify():都是Object类中的方法,因为任何对象都可以作为锁对象,因此在所有对象中都有这2个方法.

使用wait()/notify()方法前,线程需要获得对象锁,即只能在同步域中使用.
notify()方法随机唤醒一个线程.
notifyAll()则会唤醒所有等待全部线程进入就绪状态,优先级高的会先执行.

notify()方法执行后并不会释放锁,而是执行完后`run()`的内容后才会释放

wait状态下调用`interrupt()`方法会出现InterruptedException异常.


# 信号量机制

# 线程计数器

## CountDownLatch

倒计时器

允许一定量的线程等待,直到所有的线程都执行完后开始下一步操作.

```Java
// 创建计数10的倒计时器
private static CountDownLatch countDownLatch = new CountDownLatch(10);
// 减1,用于run()方法内,每个线程执行完后都会执行
countDownLatch.countDown();
// 倒计数未到0则等待,不执行该句后面的代码,所有线程都执行完后才执行
countDownLatch.await();
```

可以看出CountDownLatch阻塞的是主线程,主线程在启动其他线程后需要立即执行`countDownLatch.await()`方法,从而阻塞到所有线程执行结束.

## CyclicBarrier


```Java
CyclicBarrier barrier = new CyclicBarrier(10, new Runnable() {
            @Override
            public void run() {
                // 10个线程全部结束后执行的内容
                ......;
            }
        });
for (int i = 1; i <= 10; i++) {
    new Thread(() -> {
        try {
            // 10个线程未全部结束前一直阻塞
            barrier.await();
        } catch (Exception) {
            e.printStackTrace();
        }
    }).start();
}
```

屏障点可以设置多个,使用`barrier.reset()`方法可以重置其状态以重新执行.
不会阻塞主线程,阻塞的是子线程.

# Q&A


# 参考



[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)