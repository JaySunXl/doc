---
title: 线程安全
date: 
tags:
- Java
---
<!-- TOC -->

- [线程安全](#线程安全)
- [ThreadLocal](#threadlocal)
- [队列同步器](#队列同步器)
- [Q&A](#qa)
- [参考](#参考)

<!-- /TOC -->

# 线程安全

保证线程安全的要求:

* 原子性:一组操作,要么全部执行,要么都不执行
* 可见性:某线程对数据的修改,其他线程能立即看到
* 有序性:程序执行的顺序按照代码的先后顺序执行

> 有序性问题涉及到代码的指令重排优化

线程安全内容包括:
[synchronized](./05.synchronized.md)
[volatile](./06.volatile.md)

# ThreadLocal

ThreadLocal是线程局部变量,是一种多线程间并发访问变量的解决方案

保证数据的安全性和一致性:
锁是一种以时间换空间的方式,而ThreadLocal是一种以空间换时间的方式

Thread,ThreadLocal,ThreadLocalMap,Entry的关系:
![](https://raw.githubusercontent.com/LuVx21/doc/master/source/_posts/99.img/threadlocal.png)

ThreadLocalMap的key是ThreadLocal的弱引用,不及时清除key为空的entry,容易出现OOM,
在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value

与synchronized等加锁的方式不同,ThreadLocal完全不提供锁,而使用以空间换时间的方式,为每个线程提供变量的独立副本,以保证线程的安全

# 队列同步器

AQS: AbstractQueuedSynchronizer(抽象类)

* 用来构建锁或者其他同步组件的基础框架
* 使用一个int成员变量表示同步状态,表示当前共享资源的锁被线程获取的次数
* 使用内置的FIFO队列来完成资源获取线程的排队工作

getState(),setState(),compareAndSetState() 对同步状态进行操作
0的话表示该资源没有被线程加锁,如果是大于0则表示该资源被当前线程重入的次数

支持独占式获取与释放同步状态,共享式获取与释放同步状态

当前线程获取同步状态失败时,用AbstractQueuedSynchronizer的内部类Node封装当前线程以及等待状态等信息,
然后将Node加入FIFO队列,并阻塞当前线程.

* 同步器的主要使用方式是继承, 子类通过继承同步器并重写方法来管理同步状态；
* 子类推荐被定义为自定义同步组件的静态内部类, 同步器自身没有实现任何同步接口, 它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用.

# Q&A

# 参考

[Java并发编程:volatile关键字解析](http://www.cnblogs.com/dolphin0520/p/3920373.html)


[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)