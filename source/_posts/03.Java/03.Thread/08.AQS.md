---
title: 多线程:AQS
tags:
- Java
---
<!-- TOC -->

- [AQS(AbstractQueuedSynchronizer)](#aqsabstractqueuedsynchronizer)
- [原理](#原理)
- [Q&A](#qa)
- [参考](#参考)

<!-- /TOC -->

# AQS(AbstractQueuedSynchronizer)

AQS: AbstractQueuedSynchronizer(抽象类)

* 用来构建锁或者其他同步组件的基础框架
* 使用一个int成员变量表示同步状态,表示当前共享资源的锁被线程获取的次数
* 使用内置的FIFO队列来完成资源获取线程的排队工作

**特性**

* Lock可以让等待锁的线程响应中断, 而synchronized却不行, 使用synchronized时, 等待的线程会一直等待下去, 不能够响应中断；
* lock可以尝试获取锁, 如果锁被其他线程持有, 则返回 false, 不会使当前线程休眠(尝试非阻塞获取锁).
* lock 可以超时获取锁.
* synchronized 会自动释放锁, lock 则不会自动释放锁.
* Lock可以提高多个线程进行读操作的效率.


# 原理

state属性表示当前共享资源是否被其他线程锁占用.如果为0则表示未被占用,其他值表示该锁被重入的次数.
getState(),setState(),compareAndSetState() 对同步状态进行操作
0的话表示该资源没有被线程加锁,如果是大于0则表示该资源被当前线程重入的次数

支持独占式获取与释放同步状态,共享式获取与释放同步状态

当前线程获取同步状态失败时,用AbstractQueuedSynchronizer的内部类Node封装当前线程以及等待状态等信息,
然后将Node加入FIFO队列,并阻塞当前线程.

* 同步器的主要使用方式是继承, 子类通过继承同步器并重写方法来管理同步状态;
* 子类推荐被定义为自定义同步组件的静态内部类, 同步器自身没有实现任何同步接口, 它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用.


# Q&A



# 参考



[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)