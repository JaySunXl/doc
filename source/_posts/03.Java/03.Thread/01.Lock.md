---
title: 并发编程:锁
date:
tags:
- Java
---
<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [关于](#关于)
- [Lock](#lock)
    - [ReentrantLock](#reentrantlock)
        - [方法](#方法)
        - [Usage](#usage)
        - [实现原理](#实现原理)
- [ReadWriteLock](#readwritelock)
    - [ReentrantReadWriteLock](#reentrantreadwritelock)
        - [Usage](#usage-1)
        - [实现原理](#实现原理-1)
- [锁优化](#锁优化)
- [JVM的优化](#jvm的优化)
- [死锁预防](#死锁预防)
- [Q&A](#qa)
- [参考](#参考)

<!-- /TOC -->
</details>

## 关于


## Lock

### ReentrantLock

* 可重入的互斥锁(排它锁)
* 分为公平锁和非公平锁, 默认为非公平, 区别在于锁的获取是否按照FIFO的顺序, 但公平锁性能有所欠缺
* 通过FIFO队列管理获取该锁🔐所有线程的

可重入:

同步锁也是可重入的, 具体的一个场景就是在一个同步域内调用本类的其他由`synchronized`修饰的方法或代码块时,是永远可以得到锁的

优点是能够避免死锁: 线程获得某对象的锁后, 未释放状态下再次获取该对象的锁时, 如果不支持重入, 就会造成死锁.

![](https://dev.tencent.com/u/LuVx21/p/img/git/raw/master/ReentrantLock.jpg)

#### 方法

| 方法                                        | 说明                                                 |
| ------------------------------------------- | ---------------------------------------------------- |
| `ReentrantLock(boolean fair)`               | 有参构造, true:公平锁                                |
| `void lock()`                               | 获取锁                                               |
| `boolean tryLock()`                         | 尝试非阻塞式获取锁(方法执行后立即返回)               |
| `boolean tryLock(long time, TimeUnit unit)` | 超时时间内获取锁,获取过程中被中断,超时三种情况下返回 |
| `void lockInterruptibly()`                  | 获取锁的过程中可以中断当前线程                       |
| `void unlock()`                             | 释放锁                                               |
| `Condition newCondition()`                  | 获取等待通知组件,线程间通信用                        |

#### Usage

```Java
public static void main(String[] args) {
    Lock lock = new ReentrantLock();
    // Condition condition = lock.newCondition();// 创建Condition,可以存在多个
    new Thread(() -> doSome(lock), "thread1").start();
    new Thread(() -> doSome(lock), "thread2").start();
}
private static void doSome(Lock lock) {
    try {lock.lock();}
    ......;
    finally{lock.unlock();}
}
```

#### 实现原理

```Java
private final Sync sync;
static abstract class Sync extends AbstractQueuedSynchronizer{}
final static class NonfairSync extends Sync{}
final static class FairSync extends Sync{}
```

**加锁**

```Java
// 非公平锁
final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else // 直接使用aqs的方法
        acquire(1);
}
// 公平锁
final void lock() {
    acquire(1);
}
```

可以看到关键部分都在`acquire`方法, 其内部调用`tryAcquire`方法, 该方法需要aqs实现类来实现:

非公平锁的实现:
```Java
protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);// Sync类中实现
}
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {// 锁未被获取
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }else if (current == getExclusiveOwnerThread()) {// 独占锁持有线程是否是当前线程
        int nextc = c + acquires;// 重入次数
        if (nextc < 0) // overflow:重复次数超过65535
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

公平锁的`tryAcquire`的实现和非公平的只有一点不同, 就是`state=0`内的判断条件多了一个与条件`!hasQueuedPredecessors()`

```Java
public final boolean hasQueuedPredecessors() {
    Node t = tail;
    Node h = head;
    Node s;
    return h != t &&
            ((s = h.next) == null || s.thread != Thread.currentThread());
}
```
此方法的作用是: 判断当前线程是否为CLH队列的第一个
// TODO

**释放锁**

```Java
public void unlock() {
    sync.release(1);
}
```
其内部直接使用`tryRelease`方法, 类似的, 此方法也需要实现类进行具体实现:
```Java
protected final boolean tryRelease(int releases) {
    // 减少重入次数
    int c = getState() - releases;
    // 当前释放锁的线程不是持有该锁的线程 -> 异常
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {// 已经没有线程持有该锁 
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

## ReadWriteLock

是一个接口

ReentrantLock锁是完全排他锁,同一时间只有一个线程能执行`lock.lock()`和`lock.unlock()`之间的代码, 实际的业务场景中往往是读多写少, 而读不涉及数据竞争,
因此, 为了读而加锁必定影响其他线程的读或写, 因此出现了读写锁.

### ReentrantReadWriteLock

ReentrantReadWriteLock通过创建2个实现了Lock接口的内部类`ReadLock`,`WriteLock`来维护一对锁, 同一时间允许多个读操作进行, 实现性能的提升.
但写操作仍然是互斥的, 只要涉及到写锁, 其他线程都会被阻塞

* 读锁: 共享, 重入, 支持公平和非公平
* 写锁: 排他, 重入, 支持公平和非公平, 可降级为读锁

由于写锁是排他的,只要涉及到写操作都是互斥的,一个线程获取到写锁后不释放写锁也能继续获取到读锁,即降级为读锁.

![](https://dev.tencent.com/u/LuVx21/p/img/git/raw/master/ReentrantReadWriteLock.png)

#### Usage


#### 实现原理

```Java
private final ReentrantReadWriteLock.ReadLock readerLock;
private final ReentrantReadWriteLock.WriteLock writerLock;
final Sync sync;
public ReentrantReadWriteLock() {
    this(false);
}
public ReentrantReadWriteLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
    readerLock = new ReadLock(this);
    writerLock = new WriteLock(this);
}
abstract static class Sync extends AbstractQueuedSynchronizer {}
static final class FairSync extends Sync {}
static final class NonfairSync extends Sync {}
public static class ReadLock implements Lock, java.io.Serializable {}
public static class WriteLock implements Lock, java.io.Serializable {}
```

**锁状态的记录**

ReentrantLock中是使用AQS中的state属性记录锁的状态,ReentrantReadWriteLock有2把锁,其状态怎样记录?

在同一个整形变量上,表示2把锁的状态,就需要将这个变量按位分割使用,高16位记录读锁,低16位记录写锁.

`Sync`类内部:
```Java
static final int SHARED_SHIFT   = 16;
static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;
// 右移16位, 获取读锁状态
static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }
// 消去高16位, 获取写锁状态
static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }
```

## 锁优化

锁竞争及上下文切换会导致程序性能的下降,因此对锁的优化也是有必要的.

* 减少锁持有的时间:和降低锁粒度很相似,不要将耗时的操作放入同步域
* 减小锁粒度:Java7中ConcurrentHashMap的实现就利用了这种优化方式
* 读写锁替换独占锁:ReentrantReadWriteLock区别ReentrantLock的地方就体现出这种方式,只有涉及到写操作才会阻塞
* 锁分离:读写锁的基础上更进一步,LinkedBlockingQueue(基于链表的阻塞队列,读写分离)就使用了这种方式,存在takeLock和putLock两种锁
* 锁粗化:多个锁合并为同一个锁,与减小锁粒度相反,增大了同步域以避免频繁切换上下文,所以有特殊的适用场景
* 锁消除:编译器发现不可能被共享的对象,可以消除这些对象的锁操作,如某些类的方法时加了锁,但却用在不会有线程安全问题的情形下
* JVM的优化:偏向锁, 轻量级锁, 重量级锁等

## JVM的优化

synchronized的锁是互斥锁, 对性能有很大影响, 因此从Java6开始引入了偏向锁和轻量级锁, 以及锁的存储结构和锁升级机制.

synchronized锁是存在Java对象头中, 数组类型用3个字宽(Word)存储对象头, 其他类型用2个字宽(32位VM下1字宽为4字节).

![](https://dev.tencent.com/u/LuVx21/p/img/git/raw/master/obj_head.png)

对象头的Mark Word(32位):

| 锁状态   | 25位           | 4位          | 是否为偏向锁(1位) | 锁标志位(2位) |
| -------- | -------------- | ------------ | ----------------- | ------------- |
| 无锁状态 | 对象的hashcode | 对象分代年龄 | 0                 | 01            |

> 其中, 锁状态共有4种, 级别从低到高依次是: 无锁状态, 偏向锁状态, 轻量级锁状态和重量级锁状态, 锁可以升级且不能逆向

![](https://dev.tencent.com/u/LuVx21/p/img/git/raw/master/偏向锁.png)

![](https://dev.tencent.com/u/LuVx21/p/img/git/raw/master/轻量级锁.png)

* 自旋锁: 避免挂起线程的一种尝试.如果线程一直无法获得锁, 并且能获取的时间点也未知, 就会让当前线程做几个空循环
* 偏向锁: 偏向锁就是一旦线程第一次获得了监视对象, 之后让监视对象"偏向"这个线程, 之后的多次调用则可以避免CAS操作
* 轻量级锁: 偏向锁运行在一个线程进入同步块的情况下, 当第二个线程加入锁竞争的时候, 偏向锁就会升级为轻量级锁
* 重量级锁: JVM中又叫对象监视器(Monitor), 它至少包含一个竞争锁的队列和一个信号阻塞队列(wait队列), 前者负责做互斥, 后一个用于做线程同步.

| 锁       | 偏向锁                                                       | 轻量级锁                                 | 重量级锁                       |
| -------- | ------------------------------------------------------------ | ---------------------------------------- | ------------------------------ |
| 优点     | 加, 解锁不需要额外的消耗, 和执行非同步方法相比仅存在纳秒级差距 | 竞争的线程不会阻塞, 提高了程序的响应速度  | 线程竞争不使用自旋, 不会消耗CPU |
| 缺点     | 如果线程间存在锁竞争, 会带来额外的锁撤销的消耗                | 始终得不到锁竞争的线程, 使用自旋会消耗CPU | 线程阻塞, 响应时间慢            |
| 适用场景 | 一个线程访问同步块场景                                       | 追求响应时间, 同步块执行速度非常快        | 追求吞吐量, 同步块执行时间较长  |

## 死锁预防

以确定的顺序获得锁:在设计时即考虑到不同线程间锁获取的顺序.
超时放弃:使用synchronized获取锁时,只要没有获取到锁就会一直等待,但Lock接口实现了`tryLock()`,可以指定超时时间,

## Q&A

***synchronized和ReentrantLock***

synchronized和java.util.concurrent.locks.Lock的异同

还包括了中断锁等待和定时锁等待

在并发量小的时候, 用synchronized是比较好的选择, 并发量大的时候用Lock.
Lock有比synchronized更精确的线程语义和更好的性能.
synchronized是自动释放锁, Lock是主动释放锁, 并且必须在`finally`语句中释放
Lock可中断, 可以设定所等待的时间, 可尝试获取锁(`tryLock(long timeout, TimeUnit unit)`, 等待可中断), 可绑定多个Condition
有些操作不会发生冲突现象, 需要用Lock解决, 比如同时读文件
synchronized是非公平锁, ReentrantLock默认情况下也是非公平锁, 但可以通过带布尔值的构造函数要求使用公平锁.
都是可重入的.

> [参照1](http://blog.csdn.net/maoyeqiu/article/details/46661719)
> [参照2](https://blog.csdn.net/zheng548/article/details/54426947)

**lock的原理是什么?**

通过AQS(AbstractQueuedSynchronizer)来维护一个int
FIFO等待队列管理获取锁的所有线程.
在"公平锁"的机制下, 线程依次排队获取锁; 而"非公平锁"在锁是可获取状态时, 不管自己是不是在队列的开头都会获取锁. 

## 参考

1. [AbstractQueuedSynchronizer加锁和解锁分析(二)](http://suo.iteye.com/blog/1329460)


[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)