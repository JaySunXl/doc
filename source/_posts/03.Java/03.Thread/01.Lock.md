---
title: 并发编程:锁
date:
tags:
- Java
---
<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [Lock](#lock)
- [ReadWriteLock](#readwritelock)
- [锁优化](#锁优化)
- [JVM的优化](#jvm的优化)
- [死锁预防](#死锁预防)
- [Q&A](#qa)
- [参考](#参考)

<!-- /TOC -->
</details>

## Lock

是一个接口, 其最常见的实现类为`ReentrantLock`

```Java
void lock();
void lockInterruptibly() throws InterruptedException;
boolean tryLock();
boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
void unlock();
Condition newCondition();
```

## ReadWriteLock

是一个接口, 其最常见的实现类为`ReentrantReadWriteLock`

ReentrantLock锁是完全排他锁,同一时间只有一个线程能执行`lock.lock()`和`lock.unlock()`之间的代码, 实际的业务场景中往往是读多写少, 而读不涉及数据竞争,
因此, 为了读而加锁必定影响其他线程的读或写, 因此出现了读写锁.

仅有2个方法:
```Java
Lock readLock();
Lock writeLock();
```

## 锁优化

锁竞争及上下文切换会导致程序性能的下降,因此对锁的优化也是有必要的.

* 减少锁持有的时间:和降低锁粒度很相似,不要将耗时的操作放入同步域
* 减小锁粒度:Java7中ConcurrentHashMap的实现就利用了这种优化方式
* 读写锁替换独占锁:ReentrantReadWriteLock区别ReentrantLock的地方就体现出这种方式,只有涉及到写操作才会阻塞
* 锁分离:读写锁的基础上更进一步,LinkedBlockingQueue(基于链表的阻塞队列,读写分离)就使用了这种方式,存在takeLock和putLock两种锁
* 锁粗化:多个锁合并为同一个锁,与减小锁粒度相反,增大了同步域以避免频繁切换上下文,所以有特殊的适用场景
* 锁消除:编译器发现不可能被共享的对象,可以消除这些对象的锁操作,如某些类的方法时加了锁,但却用在不会有线程安全问题的情形下
* JVM的优化:偏向锁, 轻量级锁, 重量级锁等

## JVM的优化

synchronized的锁是互斥锁, 对性能有很大影响, 因此从Java6开始引入了偏向锁和轻量级锁, 以及锁的存储结构和锁升级机制.

synchronized锁是存在Java对象头中, 数组类型用3个字宽(Word)存储对象头, 其他类型用2个字宽(32位VM下1字宽为4字节).

![](https://dev.tencent.com/u/LuVx21/p/img/git/raw/master/obj_head.png)

对象头的Mark Word(32位):

| 锁状态   | 25位           | 4位          | 是否为偏向锁(1位) | 锁标志位(2位) |
| -------- | -------------- | ------------ | ----------------- | ------------- |
| 无锁状态 | 对象的hashcode | 对象分代年龄 | 0                 | 01            |

> 其中, 锁状态共有4种, 级别从低到高依次是: 无锁状态, 偏向锁状态, 轻量级锁状态和重量级锁状态, 锁可以升级且不能逆向

![](https://dev.tencent.com/u/LuVx21/p/img/git/raw/master/偏向锁.png)

![](https://dev.tencent.com/u/LuVx21/p/img/git/raw/master/轻量级锁.png)

* 自旋锁: 避免挂起线程的一种尝试.如果线程一直无法获得锁, 并且能获取的时间点也未知, 就会让当前线程做几个空循环
* 偏向锁: 偏向锁就是一旦线程第一次获得了监视对象, 之后让监视对象"偏向"这个线程, 之后的多次调用则可以避免CAS操作
* 轻量级锁: 偏向锁运行在一个线程进入同步块的情况下, 当第二个线程加入锁竞争的时候, 偏向锁就会升级为轻量级锁
* 重量级锁: JVM中又叫对象监视器(Monitor), 它至少包含一个竞争锁的队列和一个信号阻塞队列(wait队列), 前者负责做互斥, 后一个用于做线程同步.

| 锁       | 偏向锁                                                       | 轻量级锁                                 | 重量级锁                       |
| -------- | ------------------------------------------------------------ | ---------------------------------------- | ------------------------------ |
| 优点     | 加, 解锁不需要额外的消耗, 和执行非同步方法相比仅存在纳秒级差距 | 竞争的线程不会阻塞, 提高了程序的响应速度  | 线程竞争不使用自旋, 不会消耗CPU |
| 缺点     | 如果线程间存在锁竞争, 会带来额外的锁撤销的消耗                | 始终得不到锁竞争的线程, 使用自旋会消耗CPU | 线程阻塞, 响应时间慢            |
| 适用场景 | 一个线程访问同步块场景                                       | 追求响应时间, 同步块执行速度非常快        | 追求吞吐量, 同步块执行时间较长  |

## 死锁预防

以确定的顺序获得锁:在设计时即考虑到不同线程间锁获取的顺序.
超时放弃:使用synchronized获取锁时,只要没有获取到锁就会一直等待,但Lock接口实现了`tryLock()`,可以指定超时时间,

## Q&A

***synchronized和ReentrantLock***

synchronized和java.util.concurrent.locks.Lock的异同

还包括了中断锁等待和定时锁等待

在并发量小的时候, 用synchronized是比较好的选择, 并发量大的时候用Lock.
Lock有比synchronized更精确的线程语义和更好的性能.
synchronized是自动释放锁, Lock是主动释放锁, 并且必须在`finally`语句中释放
Lock可中断, 可以设定所等待的时间, 可尝试获取锁(`tryLock(long timeout, TimeUnit unit)`, 等待可中断), 可绑定多个Condition
有些操作不会发生冲突现象, 需要用Lock解决, 比如同时读文件
synchronized是非公平锁, ReentrantLock默认情况下也是非公平锁, 但可以通过带布尔值的构造函数要求使用公平锁.
都是可重入的.

> [参照1](http://blog.csdn.net/maoyeqiu/article/details/46661719)
> [参照2](https://blog.csdn.net/zheng548/article/details/54426947)

**lock的原理是什么?**

通过AQS(AbstractQueuedSynchronizer)来维护一个int
FIFO等待队列管理获取锁的所有线程.
在"公平锁"的机制下, 线程依次排队获取锁; 而"非公平锁"在锁是可获取状态时, 不管自己是不是在队列的开头都会获取锁.

## 参考

1. [AbstractQueuedSynchronizer加锁和解锁分析(二)](http://suo.iteye.com/blog/1329460)


[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)