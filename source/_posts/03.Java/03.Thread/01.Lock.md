---
title: 锁
date:
tags:
- Java
---
<!-- TOC -->

- [锁重入](#锁重入)
- [Lock](#lock)
- [ReentrantLock](#reentrantlock)
    - [Condition](#condition)
    - [AQS(AbstractQueuedSynchronizer)](#aqsabstractqueuedsynchronizer)
- [ReadWriteLock](#readwritelock)
    - [ReentrantReadWriteLock](#reentrantreadwritelock)
- [Future](#future)
- [锁优化](#锁优化)
- [死锁预防](#死锁预防)
- [参考](#参考)

<!-- /TOC -->
# 锁重入

具体的一个场景就是在一个同步域内调用本类的其他Synchronized修饰的方法或代码块时,是永远可以得到锁的

synchronized就拥有锁重入的特性.

能够避免死锁:线程获得某对象的锁后,未释放状态下再次获取该对象的锁时,如果不支持重入,就会造成死锁.

通过AQS（AbstractQueuedSynchronizer）来维护一个int

# Lock

| 方法                                                         | 说明                                                 |
| ------------------------------------------------------------ | ---------------------------------------------------- |
| void lock();                                                 | 获取锁                                               |
| void lockInterruptibly() throws InterruptedException;        | 获取锁的过程中可以中断当前线程                       |
| boolean tryLock();                                           | 尝试非阻塞式获取锁(方法执行后立即返回)               |
| boolean tryLock(long time, TimeUnit unit) throws InterruptedException; | 超时时间内获取锁,获取过程中被中断,超时三种情况下返回 |
| void unlock();                                               | 释放锁                                               |
| Condition newCondition();                                    | 获取等待通知组件,线程间通信用                        |

# ReentrantLock


```Java
static abstract class Sync extends AbstractQueuedSynchronizer
final static class NonfairSync extends Sync
final static class FairSync extends Sync
```


排他锁,重入锁
支持公平锁和非公平锁,提供了构造函数允许设置是否为公平锁,默认是非公平锁的

**使用**

```Java
public static void main(String[] args) {
    Lock lock = new ReentrantLock();
    // Condition condition = lock.newCondition();// 创建Condition,可以存在多个
    new Thread(() -> doSome(lock), "thread1").start();
    new Thread(() -> doSome(lock), "thread2").start();
}
private static void doSome(Lock lock) {
    lock.lock();
    ......;
    lock.unlock();
}
```

创建ReentrantLock对象时可以指定锁是否为公平锁,构造方法如下:

```Java
public ReentrantLock(boolean fair) {
   sync = fair ? new FairSync() : new NonfairSync();
}
```

## Condition

类似于Object类提供的`wait(),notify(),notifyAll()`等方法,Condition接口也提供了类似的方法`await(),signal(),signalAll()`方法,
前者配合synchronized实现等待/通知模式,同样的,后者配合Lock对象也可以实现等待/通知模式

AQS内部类ConditionObject即实现该接口,每一个Condition对象都包含一个等待队列,该队列是Condition实现等待通知机制的关键,Condition拥有首节点和尾节点

Condition.await() --> 以当前线程封装成Node(AbstractQueuedSynchronizer.Node)进入等待队列
Condition.signal() --> 唤醒等待队列中队首节点进入AQS同步队列,同时使用LockSupport唤醒该节点的线程

## AQS(AbstractQueuedSynchronizer)

用来构建锁或者其他同步组件

getState()、setState()、compareAndSetState()



# ReadWriteLock

## ReentrantReadWriteLock

ReentrantLock锁是完全排他锁,同一时间只有一个线程能执行`lock.lock()`和`lock.unlock()`之间的代码.

而ReentrantReadWriteLock则维护了一对锁,实现性能的提升.

* 读锁:共享,重入
* 写锁:排他,重入

可以看出,只要涉及到写操作都是互斥的.


获取锁:
```Java
new ReentrantReadWriteLock().readLock();
new ReentrantReadWriteLock().writeLock();
```

# Future

异步调用: 存在耗时操作,但操作的结果并不急需时,可以让其他处理和耗时操作一起处理,等待需要时再使用耗时操作的结果

# 锁优化

* 减少锁持有的时间
* 减小锁粒度:ConcurrentHashMap
* 使用读写锁替换独占锁:ReentrantLock 和 ReentrantReadWriteLock
* 锁分离:LinkedBlockingQueue(基于链表的队列,读写分离)
* 锁粗化:多个所合并为同一个锁,所以有特殊的适用场景
* 锁消除:编译器发现不可能被共享的对象,可以消除这些对象的锁操作
* JVM的优化:偏向锁, 轻量级锁, 重量级锁等

# 死锁预防

以确定的顺序获得锁:在设计时即考虑到不同线程间锁获取的顺序.
超时放弃:使用synchronized获取锁时,只要灭有获取到锁就会一直等待,但Lock接口实现了tryLock(),可以指定超时时间,

# 参考

1. [AbstractQueuedSynchronizer加锁和解锁分析(二）](http://suo.iteye.com/blog/1329460)


[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)