---
title: 锁
date:
tags:
- Java
---
<!-- TOC -->

- [锁重入](#锁重入)
- [Lock](#lock)
- [ReentrantLock](#reentrantlock)
- [ReadWriteLock](#readwritelock)
    - [ReentrantReadWriteLock](#reentrantreadwritelock)
- [锁优化](#锁优化)
- [死锁预防](#死锁预防)
- [参考](#参考)

<!-- /TOC -->
# 锁重入

具体的一个场景就是在一个同步域内调用本类的其他Synchronized修饰的方法或代码块时,是永远可以得到锁的

synchronized就拥有锁重入的特性.

能够避免死锁:线程获得某对象的锁后,未释放状态下再次获取该对象的锁时,如果不支持重入,就会造成死锁.

通过AQS（AbstractQueuedSynchronizer）来维护一个int

# Lock

| 方法                                                         | 说明                                                 |
| ------------------------------------------------------------ | ---------------------------------------------------- |
| void lock();                                                 | 获取锁                                               |
| void lockInterruptibly() throws InterruptedException;        | 获取锁的过程中可以中断当前线程                       |
| boolean tryLock();                                           | 尝试非阻塞式获取锁(方法执行后立即返回)               |
| boolean tryLock(long time, TimeUnit unit) throws InterruptedException; | 超时时间内获取锁,获取过程中被中断,超时三种情况下返回 |
| void unlock();                                               | 释放锁                                               |
| Condition newCondition();                                    | 获取等待通知组件,线程间通信用                        |

# ReentrantLock


```Java
static abstract class Sync extends AbstractQueuedSynchronizer
final static class NonfairSync extends Sync
final static class FairSync extends Sync
```


排他锁,重入锁
支持公平锁和非公平锁,提供了构造函数允许设置是否为公平锁,默认是非公平锁的

**使用**

```Java
public static void main(String[] args) {
    Lock lock = new ReentrantLock();
    // Condition condition = lock.newCondition();// 创建Condition,可以存在多个
    new Thread(() -> doSome(lock), "thread1").start();
    new Thread(() -> doSome(lock), "thread2").start();
}
private static void doSome(Lock lock) {
    lock.lock();
    ......;
    lock.unlock();
}
```

创建ReentrantLock对象时可以指定锁是否为公平锁,构造方法如下:

```Java
public ReentrantLock(boolean fair) {
   sync = fair ? new FairSync() : new NonfairSync();
}
```

# ReadWriteLock

## ReentrantReadWriteLock

ReentrantLock锁是完全排他锁,同一时间只有一个线程能执行`lock.lock()`和`lock.unlock()`之间的代码.

而ReentrantReadWriteLock则通过创建2个实现了Lock接口的内部类ReadLock,WriteLock来维护一对锁,实现性能的提升.

* 读锁:共享,重入
* 写锁:排他,重入

由于写锁是排他的,只要涉及到写操作都是互斥的,一个线程获取到写锁后不释放写锁也能继续获取到读锁,即降级为读锁.


获取锁:
```Java
new ReentrantReadWriteLock().readLock();
new ReentrantReadWriteLock().writeLock();
```

**锁状态的记录**

ReentrantLock中是使用AQS中的state属性记录锁的状态,ReentrantReadWriteLock有2把锁,其状态怎样记录?

在同一个整形变量上,表示2把锁的状态,就需要将这个变量按位分割使用,高16位记录读锁,低16位记录写锁.

# 锁优化

锁竞争及上下文切换会导致程序性能的下降,因此对锁的优化也是有必要的.

* 减少锁持有的时间:和降低锁粒度很相似,不要将耗时的操作放入同步域
* 减小锁粒度:Java7中ConcurrentHashMap的实现就利用了这种优化方式
* 读写锁替换独占锁:ReentrantReadWriteLock区别ReentrantLock的地方就体现出这种方式,只有涉及到写操作才会阻塞
* 锁分离:读写锁的基础上更进一步,LinkedBlockingQueue(基于链表的阻塞队列,读写分离)就使用了这种方式,存在takeLock和putLock两种锁
* 锁粗化:多个锁合并为同一个锁,与减小锁粒度相反,增大了同步域以避免频繁切换上下文,所以有特殊的适用场景
* 锁消除:编译器发现不可能被共享的对象,可以消除这些对象的锁操作,如某些类的方法时加了锁,但却用在不会有线程安全问题的情形下
* JVM的优化:偏向锁, 轻量级锁, 重量级锁等

# 死锁预防

以确定的顺序获得锁:在设计时即考虑到不同线程间锁获取的顺序.
超时放弃:使用synchronized获取锁时,只要灭有获取到锁就会一直等待,但Lock接口实现了tryLock(),可以指定超时时间,

# 参考

1. [AbstractQueuedSynchronizer加锁和解锁分析(二）](http://suo.iteye.com/blog/1329460)


[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)