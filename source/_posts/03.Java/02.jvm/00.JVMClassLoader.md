---
title: JVM1:类加载机制
date: 2017-11-06
tags:
- Java
- JVM
---
<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [JVM工作原理](#jvm工作原理)
- [类加载](#类加载)
- [加载的流程](#加载的流程)
- [类加载](#类加载-1)
    - [类加载的时机](#类加载的时机)
    - [类加载器](#类加载器)
    - [源码](#源码)
    - [实践](#实践)
- [Q&A](#qa)
- [参考](#参考)

<!-- /TOC -->
</details>

# JVM工作原理

JVM 主要由 `ClassLoader` 和 `执行引擎` 两子系统组成.

任何一个Java类的main方法运行都会创建一个JVM实例, 当main函数结束时, JVM实例也就结束了.
JVM实例启动时默认启动几个守护线程, 比如: 垃圾回收的线程, 而 main 方法的执行是在一个单独的非守护线程中执行的.只要母线程结束, 子线程就自动销毁, 只要非守护main 线程结束JVM实例就销毁了.

JVM的工作原理如下:

1. 根据系统环境变量, 创建装载JVM的环境与配置;
2. 寻找JRE目录, 寻找jvm.dll, 并装载jvm.dll;
3. 根据JVM的参数配置, 如: 内存参数, 初始化jvm实例;
4. JVM实例产生一个引导类加载器实例(Bootstrap Loader), 加载Java核心库, 然后引导类加载器自动加载扩展类加载器(Extended Loader),加载Java扩展库, 最后扩展类加载器自动加载系统类加载器(AppClass Loader), 加载当前的Java类;
5. 当前Java类加载至内存后, 会经过验证、准备、解析三步, 将Java类中的类型信息、属性信息、常量池存放在方法区内存中, 方法指令直接保存到栈内存中, 如: main函数;
6. 执行引擎开始执行栈内存中指令, 由于main函数是静态方法, 所以不需要传入实例, 在类加载完毕之后, 直接执行main方法指令;
7. main函数执行主线程结束, 随之守护线程销毁, 最后JVM实例被销毁;

# 类加载

* 指的是将类 Class 文件读入内存，并为之创建一个 `java.lang.Class` 对象,表示一个类, class 文件被载入到了内存之后，才能被其它 class 所引用
* jvm 启动的时候，并不会一次性加载所有的 class 文件，而是根据需要去动态加载(第一次使用时加载)
* java 类加载器是 jre 的一部分,负责动态加载 java 类到 java 虚拟机的内存
* 类的唯一性由类加载器和类共同决定

# 加载的流程

类生命周期

![](https://dev.tencent.com/u/LuVx21/p/img/git/raw/master/classload.png)

> 类: 需要由加载它的类加载器和这个类本身共同保证其在JVM中的唯一性

**加载**

通过类的全路径名获取类的二进制字节流,将类的静态内容和对象信息加载进方法区,在堆中创建对象,作为方法区数据的访问入口.

具体是将类的`.class`文件中的二进制数据读入到内存中,将其放在运行时数据区的方法区内,然后在堆区创建一个`java.lang.Class`对象,作为这个类封装在方法区内的数据结构的入口.

类的加载最终是在堆区内的Class对象,Class对象封装了类在方法区内的数据结构,并且向开发者提供了访问方法区内的数据结构的接口.

怎样加载一个类:

1. 命令行启动应用时候由JVM初始化加载
2. 通过`Class.forName()`方法动态加载
3. 通过`ClassLoader.loadClass()`方式动态加载,如`ClassLoader.getSystemClassLoader().loadClass("org.luvx.User") `

一个类被加载,当且仅当其某个静态成员(静态方法等、构造器)被调用时发生,加载一个类时,其内部类不会同时被加载。

**验证**

检查Class文件数据的正确性,是否符合当前虚拟机的要求 ,是否会危害JVM的安全等,是类加载过程中最复杂耗时的过程.

细分为以下过程:

* 文件格式验证
* 元数据验证
* 字节码验证
* 符号引用验证

**准备**

正式为类的静态内容分配内存并设置变量初始值

> 1. 进行内存分配的仅是静态变量,不包括对象变量,对象变量在对象实例化时随着对象分配在堆内存中.
> 2. 设置初始值并不是是什么就是什么,而是设置对应类型的初始值,如定义`static int num = 12`,此时设置为0,12是在上图初始化阶段设置,但`static final`修饰除外,直接就是12

**解析**

将常量池中的符号引用替换为直接引用,主要针对类或接口、字段、类方法、接口方法四类符号引用进行

> 符号引用不一定要已经加载到内存,而直接引用必定存在于内存中
> 关于符号引用, 查看以下代码的字节码:
```Java
// 符号引用
public class Test {
   public static void main() {
     String s = "adc";
     System.out.println("s=" + s);
   }
}
// 直接引用
public class Test {
   public static void main() {
     System.out.println("s=" + "abc");
   }
}
```

**初始化**

类加载的最后阶段,对静态内容进行初始化操作

Java类初始化顺序:

父类静态变量, 静态代码块->子类静态变量, 静态代码块->父类非静态变量, 非静态代码块->父类构造函数->子类非静态变量, 非静态代码块->子类构造函数

> 同一个类中静态变量, 代码块按顺序加载, 非静态变量, 代码块按顺序加载

不会加载类的情形:

1. 通过子类使用父类的静态字段,不会加载子类
2. 定义对象数组
3. 使用类名获取Class对象
4. 使用`Class.forName()`加载类时, 指定参数`initialize`为`false`
5. 使用`ClassLoader`的`loadClass()`方法加载类

> 创建一个类的数组时, 不会加载该类
以下均不涉及类的加载:
```Java
User a;
// User[] array = new User[2];
```

# 类加载

Java中的类都是在程序运行期间加载的,虽然会降低性能,但这种动态加载机制增加了灵活性,如面向接口编程中,只有运行时才能知道具体的类,可以自定义类加载器,动态加载指定的二进制数据创建对象.

## 类加载的时机

JVM规范中并没有约束类加载时机,但约束了5种情况需对类进行初始化操作,其之前的操作自然就需要完成.

1. 遇到new,getstatic,putstatic,invokestatic这4条字节码指令时(new对象时,调用静态方法,读/写静态变量,final修饰的除外)
2. 对`java.lang.reflect`包的方法对类进行反射调用
3. 初始化一个类,其父类仍没有初始化,就需要初始化父类
4. jvm启动,初始化含有`main()`方法的类
5. Java7的动态语言支持下,`java.lang.invoke.MethodHandle`的解析结果对应的类没有初始化,则需要初始化


**自己写的两个不同的类是被同一个类加载器加载的吗?为什么**

## 类加载器

类加载器的作用就是从字节码创建一个类,并负责加载 Java 应用所需的资源.

只有当一个类要使用的时候,类加载器才会加载这个类并初始化

- 启动类加载器(bootstrapClassLoader):加载Java核心库(JAVA_HOME/lib)及`-Xbootclasspath`配置,如`rt.jar`,`resources.jar`,`charsets.jar`, 不继承自`java.lang.ClassLoader`
- 扩展类加载器(ExtClassLoader):加载Java扩展库(JAVA_HOME/lib/ext)及`-D java.ext.dirs`配置
- 应用类加载器(AppClassLoader):记载当前Java类(java.class.path)
- 开发者可以通过继承`java.lang.ClassLoader`实现自定义类加载器.

> 除了启动类加载器, 其他加载器都有父类

`User user = new User()`实质就是`User user = Class.forName("org.luvx.User", false, this.class.getClassLoader()).newInstance();`

**双亲委托模型**

![](https://dev.tencent.com/u/LuVx21/p/img/git/raw/master/classloader.png)

工作过程为:一个类收到类加载的请求,首先不会自己去尝试加载,而是委派为父加载器去加载,只有当父类反馈无法加载时,才会尝试自己去加载. 如果所有加载器均加载失败, 则会抛出`ClassNotFoundException`异常.

意义: 可以保证java的一些重要类如Object在各种类加载器加载下都是同一个类,因为最终都是由启动类加载器加载,保证的类的唯一性.

存在的问题:模型本身决定的，例如基础类要掉回用户代码
怎么解决了:线程上下文类加载器

> 为什么采用双亲委派模型?

能够保证的系统类的唯一性, 如`Object`类, 最终只能由启动类加载器加载

这也就导致能写一个`java.lang,String`类, 但无法加载进JVM

**自定义类加载器**

开发者可以继承`java.lang.ClassLoader`并重写`findClass()`方法即可创建自定义类加载器.

一个类的类型是类本身和加载该类的加载器一起确定的

NoClassDefFoundError
NoSuchMethodError
ClassCastException:同一个类如果被不同的加载器加载,那他们就不是同一个类,也无法将一个类强转为另一个类,会报类转换异常,这也是`ClassLoader隔离`问题.

委派流程:
1. 加载class,会先找到自定义的类加载器
2. APPClassLoader 得到加载器请求后,向上委托交给 ExtClassLoader , ExtClassLoader 会交给 BoostrapClassLoader ,即向上委托
3. 最终到达 BoostrapClassLoader ,会先在缓存中找, 没有就尝试在自己能加载的路径去加载,找不到就交给 ExtClassLoader ,同理一直到用户自定义的 ClassLoader, 即向下查找
4. 这样保证了确保了类的唯一性

## 源码

```Java
public class Launcher {
    private static String bootClassPath = System.getProperty("sun.boot.class.path");
    public Launcher() {
        Launcher.ExtClassLoader var1;
        var1 = Launcher.ExtClassLoader.getExtClassLoader();
        this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
        Thread.currentThread().setContextClassLoader(this.loader);
    }
}
```



http://hg.openjdk.java.net/jdk8u/jdk8u60/jdk/file/935758609767/src/share/classes/sun/misc/Launcher.java

## 实践

```Java
public static void main(String[] args) {
    String p = "sun.boot.class.path";
    // p = "java.ext.dirs";
    // p = "java.class.path";
    String property = System.getProperty(p);
    String[] split = property.split(";");
    Arrays.asList(split).forEach(System.out::println);
}
```

结果如下
```
C:\Program Files\Java\jdk1.8.0_191\jre\lib\resources.jar
C:\Program Files\Java\jdk1.8.0_191\jre\lib\rt.jar
C:\Program Files\Java\jdk1.8.0_191\jre\lib\sunrsasign.jar
C:\Program Files\Java\jdk1.8.0_191\jre\lib\jsse.jar
C:\Program Files\Java\jdk1.8.0_191\jre\lib\jce.jar
C:\Program Files\Java\jdk1.8.0_191\jre\lib\charsets.jar
C:\Program Files\Java\jdk1.8.0_191\jre\lib\jfr.jar
C:\Program Files\Java\jdk1.8.0_191\jre\classes
```

# Q&A

java 的对象分配策略
在Eden中, 大对象直接进入老年代, 长期存活的对象进入老年代, 动态年龄分配, 空间分配担保

**自定义一个`java.lang.String`类, 能被加载吗**
不能, 类的包名以`java.`开头会被阻拦
`ClassLoader.preDefineClass()`方法中

```Java
if ((name != null) && name.startsWith("java.")) {
    throw new SecurityException ("Prohibited package name: " + name.substring(0, name.lastIndexOf('.')));
}
```


# 参考



[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)