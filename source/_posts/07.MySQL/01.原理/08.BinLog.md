---
title: MySQL:BinLog
date:
tags:
- MySQL
---
<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [Binlog](#binlog)
    - [关于](#关于)
    - [使用](#使用)
        - [工具](#工具)
        - [清除binlog](#清除binlog)
    - [格式](#格式)
- [主从复制](#主从复制)
    - [配置](#配置)
    - [主从复制实现细节](#主从复制实现细节)

<!-- /TOC -->
</details>

## Binlog

### 关于

记录下数据库所有的写操作, 并在事务提交时写入binlog

作用:
1. 主从复制
2. 数据恢复
3. 数据审计

日志文件位于`$MYSQL_HOME/data`下, 由一个索引文件`mysql-bin.index`和一组形如`mysql-bin.000001`的日志文件组成

索引文件是一个文本文件, 记录当前所有的日志文件

新起一个文件:

1. MySQL服务器停止或重启时
2. 执行`flush logs` 命令
3. 当 binlog 文件大小超过 max_binlog_size 变量的值时

> 如果一个事务的修改较大, 导致当前日志文件无法存下, 即使没有超过`max_binlog_size`也会新起一个文件

### 使用

```sql
-- 获取binlog文件列表
show binary logs;
-- 只查看第一个binlog文件的内容
show binlog events;
-- 查看指定binlog文件的内容
show binlog events in 'mysql-bin.000002' from 216 limit 5;
-- 查看当前正在写入的binlog文件
show master status\G
show slave status\G
-- 从库列表
show slave hosts;
-- 另起新log文件
flush logs;
-- 重置binlog
reset master
```
> show processlist;

#### 工具

```shell
mysqlbinlog -d boot 'mysql-bin.000002'
./bin/mysqlbinlog --start-datetime='2019-02-13 00:00:00' --stop-datetime='2019-02-14 00:00:00' ./data/mysql-bin.000002 > 1.sql
mysqlbinlog -h127.0.0.1 -P33306 -ucanal -pcanal --read-from-remote-server -v --start-position=296 -d dbroute_01 mysql-bin.000003
```
> --database=test

#### 清除binlog

```bash
purge { binary | master } logs { to 'log_name' | before datetime_expr }
```

Usage:
```bash
# 删除某个时间点前的日志
purge binary logs before '2019-01-01 01:01:01';
# 删除某个日志前的日志
purge binary logs to 'mysql-bin.000005';
```

设置过期时间
```sql
set global expire_logs_days = 60;
show variables like '%expire_logs_days%'
```

为什么会同时存在这样2种记录修改后数据的日志?
在修改数据时候,这两种日志的写入有没有优先顺序?

### 格式

共有3种格式:

目前常用的一般都是`row`格式的binlog, 其他的``和`statement`格式的binlog这里忽略
row: 记录下每一条数据的修改内容
statement: 记录下每一条会修改数据的sql
mixed: 两种混合

以下仅分析row格式日志

简易的binlog:

```sql
mysql> show binlog events in 'mysql-bin.004625' from 80323398;
+------------------+----------+-----------------+------------+-------------+--------------------------------------------------------------------------+
| Log_name         | Pos      | Event_type      | Server_id  | End_log_pos | Info                                                                     |
+------------------+----------+-----------------+------------+-------------+--------------------------------------------------------------------------+
| mysql-bin.004625 |        4 | Format_desc     | 1920821312 |         120 | Server ver: 5.6.16-log, Binlog ver: 4                                    |
| mysql-bin.004625 |      120 | Previous_gtids  | 1920821312 |         231 | 46c2ec79-a6f8-11e6-93a4-6c92bf2c822b:1-44429082                          |
| mysql-bin.004625 | 80327803 | Gtid            | 1920821312 |    80327851 | SET @@SESSION.GTID_NEXT= '46c2ec79-a6f8-11e6-93a4-6c92bf2c822b:44453976' |
| mysql-bin.004625 | 80327851 | Query           | 1920821312 |    80327923 | BEGIN                                                                    |
| mysql-bin.004625 | 80327923 | Table_map       | 1920821312 |    80328018 | table_id: 119 (boot.user)                                      |
| mysql-bin.004625 | 80328018 | Update_rows_v1  | 1920821312 |    80332225 | table_id: 119 flags: STMT_END_F                                          |
| mysql-bin.004625 | 80332225 | Xid             | 1920821312 |    80332256 | COMMIT /* xid=687861649 */                                               |
| mysql-bin.004625 | 80336709 | Rotate          | 1920821312 |    80336756 | mysql-bin.004626;pos=4                                                   |
+------------------+----------+-----------------+------------+-------------+--------------------------------------------------------------------------+
```

binlog文件实例, 使用mysql自带工具`mysqlbinlog`命令打开:

![00](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/df3aea56.png)

综合以上信息, 对于一个日志文件, 更详细的分解可分为:

魔数: 固定的十六进制`0xFE62696E`, 用于验证这个binlog文件是否有效

事件: 一个完整的binlog文件是由一个`format description event`开头, 一个`rotate event`结尾, 中间由多个其他event组合而成。

> Java字节码的魔数: `0xCAFEBABE`

![640a302f](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/640a302f.png)

format description event: 格式描述事件, 记录日志文件的格式及版本, 其内容如下:

| 属性          | 字节数 | 含义                                     |
| :------------ | :----- | :--------------------------------------- |
| binlogVersion | 2      | binlog版本                               |
| serverVersion | 50     | 服务器版本                               |
| timestamp     | 4      | 该字段指明该binlog文件的创建时间         |
| headerLength  | 1      | 事件头长度, 为19                         |
| headerArrays  | n      | 一个数组, 标识所有事件的私有事件头的长度 |

rotate event: 日志轮换事件, 指定下一个二进制日志文件名

每个event都是由event header 和 event data组成

以下为`update row event`内容:

![a39ad60b](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/a39ad60b.png)

```txt
+=====================================+
| event  | timestamp         0 : 4    |包含了该事件的开始执行时间
| header +----------------------------+
|        | type_code         4 : 1    |事件类型
|        +----------------------------+
|        | server_id         5 : 4    |标识产生该事件的MySQL服务器的server-id
|        +----------------------------+
|        | event_length      9 : 4    |该事件的长度(Header+Data+CheckSum)
|        +----------------------------+
|        | next_position    13 : 4    |下一个事件在binlog文件中的位置
|        +----------------------------+
|        | flags            17 : 2    |事件标志
|        +----------------------------+
|        | extra_headers    19 : x-19 |x在格式描述事件中定义, 固定值的19
+=====================================+
| event  | fixed part        x : y    |
| data   +----------------------------+
|        | variable part              |event_length - x - y
+=====================================+
```
> BI是指before image, AI是指after image。
对应的信息大致如下:
```log
#170905 01:59:33 server id 10 end_log_pos 385 CRC32 0x179ef6dd      Update_rows: table id 238 flags: STMT_END_F
UPDATE `test`.`test4` WHERE @1=3 SET @1=11;
```
> 具体事件结构可[阅读](https://dev.mysql.com/doc/internals/en/event-structure.html)

对于type_code:
常见的insert为30, update为31, delete为32, 其他事件类型可[阅读](https://dev.mysql.com/doc/internals/en/event-classes-and-types.html)

如果想要解析binlog, Java项目可以引入:
```xml
<dependency>
    <groupId>com.github.shyiko</groupId>
    <artifactId>mysql-binlog-connector-java</artifactId>
    <version>0.20.1</version>
</dependency>
```

## 主从复制

### 配置

```conf
[mysqld]
log-bin=mysql-bin
binlog-format=ROW
server_id=20001
# 监测从库时开启
# log_slave_updates=1
# 忽略同步的库
binlog-ignore-db=mysql
# 同步的库
binlog-do-db=java
# 主从超时重连时间
slave_net_timeout = 60
```
用户:
```sql
create user canal identified by 'canal';
grant select, replication slave, replication client on *.* to 'canal'@'%';
-- grant all privileges on *.* to 'canal'@'%' ;
flush privileges;
```
> select Select_priv, Repl_slave_priv, Repl_client_priv from mysql.user;

### 主从复制实现细节

![](https://dev.tencent.com/u/LuVx21/p/img/git/raw/master/mysql-replication.jpg)

1. master将写操作发生的更改写入binlog(二进制日志), 其中记录着事件, 对应着写操作
2. salve将master的事件拷贝到它的relay log(中继日志)
3. slave将事件中的更改反映在自身, 从而与master保持一致

以上复制过程是使用3个线程实现的, 一个在master上, 两个在slave上:
* Binlog dump: master创建这个线程以便在slave连接时发送binlog到slave, master获取binlog的锁以读取binlog并发送到slave, 读取完毕后即使没有发送到slave就会释放锁, 可以使用`show processlist`命令查看该线程
* Slave I/O: slave执行了`start slave`语句后, slave会创建该线程, 用以连接master并请求master发送binlog中的更新, 并拷贝这些内容到中继日志, 等待SQL线程读取并执行, 可以使用`show slave status`查看该线程
* Slave SQL: slave创建该线程去读取中继日志, 并执行其中的事件

以上3个线程只存在于一个主从连接中, 一主多从的场景下会为每个主从连接创建一个`Binlog dump`, 同时每个slave具有自己的I/O和SQL线程

push: 主动推送
pull: 主动拉取
send: 发送, 不含主动色彩
另外, 第一次和以后的过程可能不同

可能支持`push`的证据:

* https://blog.51cto.com/coosh/1784315
* http://www.orczhou.com/index.php/2011/11/how-mysql-send-the-binary-log/
* https://www.cnblogs.com/kevingrace/p/6274073.html
* [canal作者issue的回答](https://github.com/alibaba/canal/issues/1853)

`show slave status;`

结果: `Waiting for master to send event`

`The master creates a thread to send the binary log contents to a slave when the slave connects.`
[出处](https://dev.mysql.com/doc/refman/5.6/en/replication-implementation-details.html)

可能支持`pull`的证据:

`Each slave that connects to the master requests a copy of the binary log. That is, it pulls the data from the master, rather than the master pushing the data to the slave.`
[出处](https://dev.mysql.com/doc/refman/5.6/en/replication-implementation.html)

`When a START SLAVE statement is issued on a slave server, the slave creates an I/O thread, which connects to the master and asks it to send the updates recorded in its binary logs.`
[出处](https://dev.mysql.com/doc/refman/5.6/en/replication-implementation-details.html)

结论:
> 发送(send)是由master做
> 首次`slave start`后是pull, 之后master有新的修改, 则是push过程
> 未开始同步时, slave是否准备好只有slave知道, master产生了新修改只有master知道
> 若slave循环pull, 会导致资源浪费, 实时性差

QA

全量数据的快照创建是一个过程, 此间可能产生新的更改
快照传送并恢复到从库也是一个过程, 此间可能产生新的更改

https://cloud.tencent.com/developer/article/1020356


[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)
