---
title: 源码解读-ArrayList
date: 2018-03-14
tags:
- Java
---
<!-- TOC -->

- [Q](#q)

<!-- /TOC -->

```Java
// 构造数组用默认大小
private static final int DEFAULT_CAPACITY = 10;
// 默认
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
// 存储用数组
transient Object[] elementData;
// 元素个数
private int size;
```

* 底层是数组,默认大小为10
* 扩容后,为原来的1.5倍
* 实现了RandomAccess接口,因此是随机访问模式
* 使用transient关键字,使底层数组不被序列化
* 增删慢,改查快

底层存储是动态数组,为保证不将null元素序列化,将elementData声明为transient,即忽略序列化,
但是实现writeObject 和 readObject方法进行用户自定义的序列化和反序列化.

```Java
List<String> list = new ArrayList<String>();
/**
* 扩容校验->grow()扩容1.5倍
*/
list.add("1");
list.get(0);
list.set(0, "a");
/**
* 下标校验->获取旧值->移动->置空
*/
list.remove(0);
System.out.println(list);
```

```Java
// Arrays
public static <T> T[] copyOf(T[] original, int newLength)
// System,将源数组src从srcPos位置开始拷贝length个元素到dest数组的destPos位置
public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);
```


contains():是否使用了hashcode进行判断,具体怎样实现


非线程安全,若想应用于多线程环境,可以Collections.synchronizedList()方法
```Java
List<String> synchronizedList = Collections.synchronizedList(list);
```

# Q

**底层的数组为什么用transient修饰(为什么不序列化)**

