---
title: 源码解读-ArrayList
date: 2018-03-14
tags:
- Java
---
<!-- TOC -->

- [构造](#构造)
- [例](#例)
- [线程安全问题](#线程安全问题)
- [序列化问题](#序列化问题)

<!-- /TOC -->

# 构造

```Java
// 构造数组用默认大小
private static final int DEFAULT_CAPACITY = 10;
// 默认
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
// 存储用数组
transient Object[] elementData;
// 元素个数
private int size;
```

* 底层是数组,默认大小为10
* 扩容后,为原来的1.5倍,使用了位运算
* 实现了RandomAccess接口,因此是随机访问模式
* 使用transient关键字,使底层数组不被序列化
* 增删慢,改查快
* 非线程安全

底层存储是动态数组,为保证不将null元素序列化,将elementData声明为transient,即忽略序列化.

# 例

```Java
List<String> list = new ArrayList<String>();
/**
* 扩容校验->grow()扩容1.5倍
*/
list.add("1");
list.get(0);
list.set(0, "a");
/**
* 下标校验->获取旧值->前移->置空
*/
list.remove(0);
System.out.println(list);
```

扩容1.5倍仍然不能存储所有元素时,就会扩容所需要的大小,即最终大小为size+minCapacity.

扩容后,将原数组的数据移动到新数组上,移动操作是用的native方法:

```Java
// Arrays
public static <T> T[] copyOf(T[] original, int newLength)
// System,将源数组src从srcPos位置开始拷贝length个元素到dest数组的destPos位置
public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);
```

# 线程安全问题

非线程安全,若想应用于多线程环境,可以Collections.synchronizedList()方法
```Java
List<String> synchronizedList = Collections.synchronizedList(list);
```

# 序列化问题

源码中可以看到,真正的存储容器elementData是一个数组,那么它就有可能不会放满元素,
为了节约空间,传输数据包的最小化,选择使用transient修饰,所以在序列化一个ArrayList对象时,这个数组是不被实例化的.
ArrayList自身实现了以下方法用以序列化和反序列化:
```Java
private void writeObject(java.io.ObjectOutputStream s)
private void readObject(java.io.ObjectInputStream s)
```

[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)