---
title: 源码解读-ArrayList
date: 2018-03-14
tags:
- Java
---
<!-- TOC -->

- [构造](#构造)
- [例](#例)
- [](#)
- [Q](#q)

<!-- /TOC -->

# 构造

```Java
// 构造数组用默认大小
private static final int DEFAULT_CAPACITY = 10;
// 默认
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
// 存储用数组
transient Object[] elementData;
// 元素个数
private int size;
```

* 底层是数组,默认大小为10
* 扩容后,为原来的1.5倍,使用了位运算
* 实现了RandomAccess接口,因此是随机访问模式
* 使用transient关键字,使底层数组不被序列化
* 增删慢,改查快
* 非线程安全

底层存储是动态数组,为保证不将null元素序列化,将elementData声明为transient,即忽略序列化,
可以实现writeObject 和 readObject方法进行自定义的序列化和反序列化.

# 例

```Java
List<String> list = new ArrayList<String>();
/**
* 扩容校验->grow()扩容1.5倍
*/
list.add("1");
list.get(0);
list.set(0, "a");
/**
* 下标校验->获取旧值->前移->置空
*/
list.remove(0);
System.out.println(list);
```

扩容1.5倍仍然不能存储所有元素时,就会扩容所需要的大小,即最终大小为size+minCapacity.

扩容后,将原数组的数据移动到新数组上,移动操作是用的native方法:

```Java
// Arrays
public static <T> T[] copyOf(T[] original, int newLength)
// System,将源数组src从srcPos位置开始拷贝length个元素到dest数组的destPos位置
public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);
```

# 

非线程安全,若想应用于多线程环境,可以Collections.synchronizedList()方法
```Java
List<String> synchronizedList = Collections.synchronizedList(list);
```

# Q

**底层的数组为什么用transient修饰(为什么不序列化)**


[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)