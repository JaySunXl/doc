---
title: 源码解读-String
date: 2018-03-14
tags:
- Java
---
<!-- TOC -->

- [String](#string)
- [StringBuilder](#stringbuilder)
- [StringBuffer](#stringbuffer)

<!-- /TOC -->

# String

位于`java.lang`包下,
实现了Serializable, Comparable, CharSequence接口.


成员变量
```Java
// 数据存储的位置
private final char value[];
// 对象的hash码
private int hash;
```

类本身是final的,所以String类是不能继承的,
底层存储(char型数组)也是final的,这也是String类型数据不可变的原因,
对字符串进行更改时,以`substring()`为例,实质是将创建一个新的数组,将原数组元素截取后拷贝到新的数组中,同时返回一个String对象(查看源码即可看出return语句中有new指令的存在).
由于final的存在,上述数组引用`value`不能重新指向新的字符数组,所以实质是返回一个新的String对象,数组也不再是原来的数组了.

成员方法
```Java
public int hashCode()
// 仅比较字符串内容
public boolean equals()
// 此方法会检查常量池中是否有当前对象的字符串,有则返回此字符串的对象,无则将该字符串加入常量池并返回此对象的引用←since jdk7
public native String intern()
```

分析一段代码
```Java
public void stringTest() {
    // 没有字符串运算,本身就是"a b c"
    String s = "a " + "b " + "c";
    String ss = "a b c";
    String sss = new String("a b c");
    System.out.println(s == ss);// true
    System.out.println(ss == sss);// false

    // since jdk7
    String s0 = new StringBuilder("a ").append("b c").toString();
    String s1 = new StringBuilder("a ").append("b c1").toString();
    System.out.println(s0.intern() == s0);// false(常量池中存在),函数返回其实是s
    System.out.println(s1.intern() == s1);// true(常量池中不存在),jdk7之前为false
}
```

首先,s虽然有`+`,但并没有运算,实质上还是`a b c`同时存入常量池,而ss会去常量池中查找,存在则返回既有的地址,因此s和ss是相同的,
而sss使用了new指令,则会在堆内存中开辟存储空间,所以其内存地址和ss是不一样的,因而是不同的.
后两个则显而易见.

# StringBuilder

继承自`AbstractStringBuilder`

```Java
char[] value;
int count;
```
底层存储是父类的char型数组,默认大小为16,对应于capacity这个概念
使用count计量数组中的元素个数.

和String相比,虽然同样是使用字符数组,但没有final的修饰,以`append()`为例,其返回值是this,没有new指令存在,即没有创建新的对象.
具体的拼接操作其实是在`AbstractStringBuilder.append()`中实现的,首先进行容量检测,然后将原有和追加的字符都拷贝到新的数组,并用`value`重新指向该数组.
从而实现对象不变,其内部存储的内容改变的效果(仅仅是引用的对象改变了).

# StringBuffer

基本和StringBuilder相同
