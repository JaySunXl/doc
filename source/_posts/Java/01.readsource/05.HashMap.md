---
title: 源码解读-HashMap
date: 2018-03-14
tags:
- Java
---

<!-- TOC -->

- [关于Hash](#关于hash)
- [](#)

<!-- /TOC -->

# 关于Hash

通常来说Hash算法具有以下特征,

* 输入和哈希值是多对一的关系,即是一种压缩映射.最优情况是一对一
* 哈希值不同,输入肯定不同
* 哈希值相同,输入可能不同
* 同样的输入,哈希值必须相同
* 不同的输入,同样的哈希值,这种现象被称为哈希碰撞,碰撞几率是衡量一个哈希算法优劣的重要指标.

解决碰撞的方案:

* 开放定址法:一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入
* 链地址法:将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部
* 再哈希法:当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止
* 建立公共溢出区:将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中

HashMap即是采用链地址法,结合数组和链表两者的优势.

# 

```Java
Map<String, String> map = new HashMap<String, String>();
map.put("b", "B");
map.put("a", "A");
map.put("c", "C");

for (Map.Entry<String, String> entry : map.entrySet()) {
    System.out.println(entry.getKey() + ":" + entry.getValue());
}
// a:A
// b:B
// c:C
```

```Java
transient Node<K,V>[] table;
transient Set<Map.Entry<K,V>> entrySet;
transient int size;
transient int modCount;
```

底层:数据+链表+红黑树

int hash(Object k)

```Java
// Callbacks to allow LinkedHashMap post-actions
void afterNodeAccess(Node<K,V> p) { }
void afterNodeInsertion(boolean evict) { }
void afterNodeRemoval(Node<K,V> p) { }
```


1. java HashMap的原理.

是怎么存放的, 发生hash碰撞怎么做, 为什么get请求的算法复杂度会接近O(1)
了不了解ConcurrentHashMap
原理是什么, 如果答出了分段锁之类的, 再问一下java7和java8有什么不一样, 因为在8的时候做了很多改变, 已经不是以前那种Segement了, 改用了node数组, 扩容是怎么扩的, 扩容也是分段扩的, 并不是整个桶一起扩的.