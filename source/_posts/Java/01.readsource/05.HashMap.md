---
title: 源码解读-HashMap
date: 2018-03-14
tags:
- Java
---

<!-- TOC -->

- [关于Hash](#关于hash)
- [结构](#结构)
- [例](#例)

<!-- /TOC -->

# 关于Hash

通常来说Hash算法具有以下特征,

* 输入和哈希值是多对一的关系,即是一种压缩映射.最优情况是一对一
* 哈希值不同,输入肯定不同
* 哈希值相同,输入可能不同
* 同样的输入,哈希值必须相同
* 不同的输入,同样的哈希值,这种现象被称为哈希碰撞,碰撞几率是衡量一个哈希算法优劣的重要指标.

解决碰撞的方案:

* 开放定址法:一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入
* 链地址法:将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部
* 再哈希法:当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止
* 建立公共溢出区:将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中

HashMap即是采用链地址法,结合数组和链表两者的优势.

# 结构

```Java
// 默认大小
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;
// 默认扩容因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;
// 节点类
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;// key的hash值
    final K key;
    V value;
    Node<K,V> next;// key的hash值相同时使用
}
transient Node<K,V>[] table;
transient Set<Map.Entry<K,V>> entrySet;
transient int size;
```

* 默认初始化大小为16
* 存储容器为数组,即代码中的属性table,存储的是节点而不是键值对
* key可以为null
* 非线程安全

采用静态内部类作为节点,
底层:数据+链表+红黑树


public HashMap(int initialCapacity, float loadFactor) {}
自定义初始化大小和扩容因子.

为什么要自定义一个hash方法?
```Java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

int hash(Object k)

```Java
// Callbacks to allow LinkedHashMap post-actions
void afterNodeAccess(Node<K,V> p) { }
void afterNodeInsertion(boolean evict) { }
void afterNodeRemoval(Node<K,V> p) { }
```

# 例

```Java
Map<String, String> map = new HashMap<String, String>();
// 
map.put("b", "B");
map.put("a", "A");
map.put("c", "C");

for (Map.Entry<String, String> entry : map.entrySet()) {
    System.out.println(entry.getKey() + ":" + entry.getValue());
}
```


1. java HashMap的原理.

是怎么存放的, 发生hash碰撞怎么做, 为什么get请求的算法复杂度会接近O(1)
了不了解ConcurrentHashMap
原理是什么, 如果答出了分段锁之类的, 再问一下java7和java8有什么不一样, 因为在8的时候做了很多改变, 已经不是以前那种Segement了, 改用了node数组, 扩容是怎么扩的, 扩容也是分段扩的, 并不是整个桶一起扩的.

[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)