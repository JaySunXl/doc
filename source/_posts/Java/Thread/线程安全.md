---
title: 线程安全
date: 
tags:
- Java
---
<!-- TOC -->

- [volatile](#volatile)
- [synchronized](#synchronized)
- [ThreadLocal](#threadlocal)
- [队列同步器](#队列同步器)

<!-- /TOC -->

# volatile

处理器 内部缓存 内存 
缓存一致性协议

* 禁止指令重排序优化
* 提供多线程访问共享变量的内存可见性,即告诉所有使用该被共享变量的线程,对其读写都可能要和共享内存发生交互

对此共享变量写操作时会有下面操作:

1. 会将缓存的数据写回共享内存
2. 同时使其他线程的该变量声明为无效(不是最新)

![](./img/volatile.png)

> 指令重排序优化:
> JVM为了优化指令,提高程序运行效率,在不影响单线程程序执行结果的前提下,尽可能地提高并行度,因此多线程下的优化会给开发者带来问题,
> 可能导致代码的执行顺序可能不是书写的顺序,对变量的修改无法告知所有操作该变量的其他线程.

# synchronized

可以修饰方法,代码块,确保多个线程在同一个时刻,只能有一个线程处于方法或者同步块中,以保证线程对变量访问的可见性和排他性
无论是修饰方法还是代码块都是获取一个对象的监视器(monitor)然后才能进入同步块或者同步方法,
而获取过程是排他的,也就是说同一时刻只有一个线程获取到由synchronized所保护对象的监视器,没有获取到的线程就会被阻塞.

使用synchronized加锁:

对于普通变量,方法所加的锁都是对象锁,一个对象一把锁,互不影响
对于静态变量,方法所加的锁都是类锁,此类的所有对象共用一把锁

锁一共有4种状态,级别从低到高依次是：无锁状态,偏向锁状态,轻量级锁状态和重量级锁状态

锁存储在Java对象头中,其中的`Mark Word`包含: 锁状态, HashCode,分代年龄,是否是偏向锁和锁标记位

自旋锁: 避免挂起线程的尝试.线程一直无法获得锁,而能获取的时间点也未知,就会让当前线程做几个空循环


> 局部变量不会发生线程安全问题.

> synchronized支持锁重入
> 锁重入:自己可以获取自己的内部锁.
> 当线程请求一个由其它线程持有的对象锁时,该线程会阻塞,而当线程请求由自己持有的对象锁时,如果该锁是重入锁,请求就会成功,否则阻塞


# ThreadLocal


保证数据的安全性和一致性:
锁是一种以时间换空间的方式,而ThreadLocal是一种以空间换时间的方式


# 队列同步器

AQS: AbstractQueuedSynchronizer(抽象类)

* 用来构建锁或者其他同步组件的基础框架
* 使用一个int成员变量表示同步状态,表示当前共享资源的锁被线程获取的次数
* 使用内置的FIFO队列来完成资源获取线程的排队工作

getState()、setState()、compareAndSetState() 对同步状态进行操作
0的话表示该资源没有被线程加锁，如果是大于0则表示该资源被当前线程重入的次数

支持独占式获取与释放同步状态、共享式获取与释放同步状态

当前线程获取同步状态失败时,用AbstractQueuedSynchronizer的内部类Node封装当前线程以及等待状态等信息,
然后将Node加入FIFO队列,并阻塞当前线程.

* 同步器的主要使用方式是继承, 子类通过继承同步器并重写方法来管理同步状态；
* 子类推荐被定义为自定义同步组件的静态内部类, 同步器自身没有实现任何同步接口, 它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用。
