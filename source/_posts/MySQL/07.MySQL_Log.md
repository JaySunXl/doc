---
title: MySQL:日志
date: 
tags:
- MySQL
---
<!-- TOC -->

- [事务日志](#事务日志)
    - [undo log](#undo-log)
    - [redo log](#redo-log)
- [慢查询日志](#慢查询日志)

<!-- /TOC -->


1. 回滚日志(undo log)
2. 重做日志(redo log)
3. 二进制日志(binlog)
4. 错误日志(errorlog)
5. 慢查询日志(slow query log)
6. 一般查询日志(general log)
7. 中继日志(relay log)

1,2合并即为事务日志

# 事务日志

ACID特性主要是通过事务日志来实现.

为什么会有事务日志?
事务日志的存在,使得事务提交时,不用同时将脏页刷新到磁盘上,
因为多数事务的提交都是修改的随机位置上的数据,索引等,因此需要通过很多随机IO,而事务日志的就是将随机IO转化为顺序IO,日志正确地被写入磁盘,这个事务就可以说是持久化了,剩下的就是刷新数据到磁盘(此时已经有所有修改的位置,可以智能调整修改的写入顺序,减少IO的随机度),即使此时中途宕机,也可以通过日志恢复数据.

先日志后数据

* Data
* Data Buffer
* Redo Log
* Redo Log Buffer

> Data buffer 也可以被称为dirty page

在事务执行时,表中的数据会被加载进内存.同样的,事务日志,在内存中也有一个副本,
在修改数据时,修改的是内存中的数据,同时会写入一条记录进日志缓冲区,当满足一定的条件(缓冲区满,事务提交,到达自定义刷新时间),就会刷新缓冲区日志进入磁盘日志文件,
在日志副本持久化后,数据副本持久化到磁盘,或者说是真正的完成修改数据库.


为什么是先持久化日志?假如在事务提交后,数据持久化前,发生故障,为了保证CrashSafe,故障恢复后,已提交的事务,自动将未持久化的数据写入数据库.
而反过来先持久化数据,一旦


在故障恢复中其中重要的作用.

事务的回滚操作是通过undo log实现,保证了事务的原子性.
redo log保证了事务的持久性,事务提交后宕机恢复后重新持久化未存储的数据

## undo log

undo日志记录数据修改前的值,用于执行事务回滚

## redo log

记录的是已提交的事务
redo日志记录数据修改后的值,用于恢复未从内存写入数据库的数据




mysql中还有另外一种日志:bin log(二进制日志),也是存储的修改后的数据,为什么会同时存在这样两种日志?
在修改数据时候,这两种日志的写入有没有优先顺序?
bin log常用于主从复制

Write Ahead Log机制:
Double Write机制:Double Write Buffer
Check Point机制:某个时间data buffer 中的数据被刷新到磁盘中,这个时间点会被计入redo log的最后,进行redo 操作时只需要redo 这个点之后的数据.

# 慢查询日志

|参数|说明|
|:---|:---|
|slow_query_log|慢查询日志控制变量,ON:启用,此时会记录执行时间超过设定值的查询|
|slow_query_log_file|慢查询日志的文件名|
|long_query_time|当查询执行时间超过设定值,会被记录的慢查询日志中,单位是s|
|log_queries_not_using_indexes|没有使用索引的查询日志控制变量,ON:启动,此时会记录未使用索引的查询,无论查询的快慢|

> 使用`show variables like 'xx';`查看上述变量

开启慢查询,修改my.cnf文件:
```conf
log-output=FILE
slow_query_log=1
log-slow-queries=/data/mysql_data/slow_query.log
long_query_time=1
```

`show processlist`:显示哪些线程正在运行


mysqlsla:日志分析工具


其他日志参看:

[MySQL日志管理](https://segmentfault.com/a/1190000003072237)
[](http://www.cnblogs.com/duanxz/p/3440414.html)


[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)