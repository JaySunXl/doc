---
title: Redis基础
date: 2017-05-11
tags:
- Redis
- NoSQL
---
<!-- TOC -->

- [关于](#关于)
- [配置](#配置)
- [使用](#使用)
- [命令](#命令)
    - [共有命令](#共有命令)
- [数据类型](#数据类型)
    - [String](#string)
    - [list](#list)
    - [hash](#hash)
    - [set](#set)
    - [zset](#zset)
    - [HyperLogLog](#hyperloglog)
    - [Geo](#geo)
    - [Pub/Sub](#pubsub)
- [调用Redis](#调用redis)
- [使用场景](#使用场景)
- [持久化](#持久化)
- [主从复制](#主从复制)

<!-- /TOC -->

# 关于

特点:

* key-value形式存储
* 单进程单线程,区别于Memcached的单进程多线程
* 支持string,list,set,zset,hash等数据类型

Redis 将数据储存在内存里面,读写数据的时候都不会受到硬盘 I/O 速度的限制,所以速度极快

使用场景:

* 分布式缓存
* 分布式session
* 数据量大,高并发的场景下

**Redis和Memcache对比**

* 都是内存数据库,但Memcache还可以缓存其他东西,如图片视频
* Redis支持数据持久化,memcache不支持,挂掉后,数据不可恢复
* Redis有数据类型所以会占用更多的空间
* Redis原生支持集群
* 支持分布式,memcache集群,利用magent做一主多从;redis可以做一主多从,也可以一主一从
* redis中数据不是一直在内存中,Memcache则是一直都在

Memcache相关可以阅读[Memcache详细解读](http://www.cnblogs.com/xrq730/p/4948707.html)

# 配置

config命令
```shell
#获取配置信息
config get <settingname>
config set <settingname> <value>
```

设置密码
```shell
config set requirepass 1121
redis-cli -h 127.0.0.1 -p 6379 -a 1121
```

配置后台运行
redis.conf
```shell
# daemonize no
daemonize yes
```

# 使用

启动服务

```shell
redis-server redis.conf
```

关闭服务
```shell
redis-cli -p 6379 shutdown
```

进入命令行
```shell
redis-cli -h host -p port -a password
```

> 默认监听`6379`端口

# 命令

## 共有命令

| 命令   | 说明                 | 例               |
| :----- | :------------------- | :--------------- |
|        | 取出所有key          | keys *           |
|        | 支持正则表达式       | keys "foo*"      |
|        | 查看数据类型         | type <key>       |
|        | 重命名key            | rename <key>     |
|        | 追加value            | append <key>     |
|        | 判断存在             | exists <key>     |
|        | 增1                  | incr <key>       |
|        | 减1                  | decr <key>       |
|        | 增i                  | incrby <key> <i> |
|        | 减i                  | decrby <key> <i> |

| 命令      | 说明                 | 例                       |
| :-------- | :------------------- | :----------------------- |
| expire    | 设置存活时间(秒)     | expire key seconds       |
| pexpire   | 设置存活时间(毫秒)   | pexpire key milliseconds |
| expireat  | 设置过期时间点(秒)   |                          |
| pexpireat | 设置过期时间点(毫秒) |                          |
|           | 取消失效             | persist key              |
|           | 键值对数量           | dbsize                   |
|           | 清空数据库           | flushdb                  |
|           | 服务信息             | info                     |

# 数据类型

> 不能存储中文, 存储unicode可以实现间接存储中文

## String

最简单的k-v类型,k或v都可以为字符串或数字

| 命令        | 说明                                                         | 例                            |
| :---------- | :----------------------------------------------------------- | :---------------------------- |
| set         | 插入键值, 存在则覆盖                                         | set k v                       |
| get         | 查看value                                                    | get k                         |
| setnx       | key存在则什么都不做,不存在与set相同                          | setnx k v                     |
| mset        | 批量插入键值, 存在则覆盖                                     | mset k1 v1 k2 v2              |
| mget        | 批量查看                                                     | mget k1 k2                    |
| msetnx      | mset和setnx的组合效果,如果任意key存在,则全部都不设值         | msetnx k1 v1 k2 v2            |
| getset      | 取值并设置新值,和set的不同在于返回旧值                       | getset  k v                   |
| setex       | 在set基础上设置过期时间,使用ttl查看剩余时间                  | setex key seconds value       |
| psetex      | 同setex,时间单位是毫秒,使用pttl查看剩余时间                  | psetex key milliseconds value |
| setrange    | 从offset处开始用value替换,offset大于总长度则用0补齐 ,不存在则新加 | setrange k offset value       |
| getrange    | 获取指定区间内的内容,下标可以为负数                          | getrange key start end        |
| del         | 删除键值对                                                   | del k                         |
| strlen      | 获取长度                                                     | strlen k                      |
| append      | 给key的字符串追加value,返回新的字符串长度,不存在则新加      | append k v                    |
| incr        | 递增,key不存在则value置为1,value为非数组类型则报错           | incr k                        |
| decr        | 递减                                                         | decr k                        |
| incrby      | 能指定步长的递增                                             | incrby k n                    |
| decrby      | 能指定步长的递减                                             | decrby k n                    |
| incrbyfloat | n可以为浮点数                                                | incrbyfloat k n               |


bit操作:字符串类型是以二进制形式存储,bit操作就是对这个二进制进行的操作

| 命令   | 说明                        | 例                |
| :----- | :-------------------------- | :---------------- |
| getbit |                             | getbit key offset |
| setbit |                             | setbit key offset |
|        | 统计二进制存储中1的个数     | bitcount key      |
|        | 对二进制进行与或非,异或运算 | bitop [and        |

nil:空

## list

基于双向循环链表实现, 栈,元素允许重复.

| 命令      | 说明                                                         | 例                                              |
| :-------- | :----------------------------------------------------------- | :---------------------------------------------- |
| *push     | 入栈                                                         | lpush foo bar<br/>rpush foo bar                 |
| *pop      | 出栈,返回出栈的元素                                          | lpop foo<br/>rpop foo                           |
| b*pop     | 阻塞式弹出                                                   | blpop foo<br/>brpop foo<br/>ltrim key start end |
| lrange    | 查看指定区域元素,0 -1:全部                                   | lrange key start stop                           |
| lindex    | 指定位置的元素                                               | lindex key index                                |
| llen      | 元素的个数                                                   | llen key                                        |
| lrem      | 从list中删除count个value,返回删除的个数,count:0全删除,<0从后开始删 | lrem key count value                            |
| linsert   | 在指定的元素前/后添加元素                                    | linsert key before/after foo bar                |
| lset      | 设置指定位置的值                                             | lset key index value                            |
| ltrim     | 截取指定范围内元素,其余的删除,返回ok成功                     | ltrim key start end                             |
| rpoplpush | 从第1个list右边弹出后,从左边放入新的list                     | rpoplpush list1 list2                           |


## hash

适合用于存储对象

| 命令    | 说明                    | 例                                  |
| :------ | :---------------------- | :---------------------------------- |
| hset    | 添加                    | hset key field value                |
| hget    | 查看                    | hget key field                      |
| hmset   | 批量添加                | hmset key field value field1 value1 |
| hmget   | 批量查看                | hmget key field field1              |
| hsetnx  | 存在则不做操作          | hsetnx key field value              |
| hlen    | 键值对数来能            | hlen key                            |
| hdel    | 删除键值对              | hdel key field field1               |
| hincrby | 将hash表中的某value增加 | hincrby key field increment         |
| hexists | 判断hash表中是否有存在  | hexists key field                   |
| hkeys   | 查看所有key             | hkeys key                           |
| hvals   | 查看所有value           | hvals key                           |
| hgetall | 查看所有key-value       | hgetall                             |

## set

无序, 不可重复,支持并集,交集和差集运算.
底层基于hashtable实现.

| 命令        | 说明                             | 例                             |
| :---------- | :------------------------------- | :----------------------------- |
| sadd        | 增加元素                         | sadd key member [member ...]   |
| srem        | 删除元素                         | srem key member [member ...]   |
| smembers    | 遍历                             | smembers key                   |
| sismember   | 判断存在                         | sismember key member           |
| scard       | 元素个数                         | scard key                      |
| srandmember | 随机返回count个value             | srandmember key [count]        |
| spop        | 和srandmember相似,但会删除返回的 | spop key [count]               |
| smove       | 跨集合移动元素                   | smove key1 key2 value          |
| sunion      | 并集                             | sunion,sunionstore             |
| sinter      | 交集                             | sinter,sinterstore             |
| sdiff       | 差集                             | sdiff key1 key2                |
| sunionstore | 保存并集到destkey                | sunionstore destkey key1 keys2 |
| sinterstore | 保存交集到destkey                | sinterstore destkey key1 keys2 |
| sdiffstore  | 保存差集到destkey                | sdiffstore destkey key1 key2   |

## zset

有序set,相比于set增加了权重参数score,也是实现有序的关键,默认以score升序.


| 命令             | 说明                               | 例                               |
| :--------------- | :--------------------------------- | :------------------------------- |
| zadd             | 添加元素                           | zadd key score member            |
| zrange           | 查看指定范围内元素                 | zrange key m n withscores        |
| zrangebyscore    | 按照scores顺序输出元素             | zrangebyscore key m n withscores |
| zrevrange        | 类似于zrange,但是逆序              | zrevrange key m n                |
| zrem             | 删除集合中某元素                   | zrem key member                  |
| zremrangebyrank  | 删除指定区间内所有元素(索引顺序)   | zremrangebyrank key m n          |
| zremrangebyscore | 删除指定区间内所有元素(权重顺序)   | zremrangebyscore key m n         |
| zincrby          | 修改元素的score,若元素不存在则添加 | zincrby key score member         |
| zrank            | 查看元素索引                       | zrank key member                 |
| zrevrank         | 查看逆序索引                       | zrevrank key member              |
| zcount           | 指定区间内元素的数量               | zcount key m n                   |
| zcard            | 元素的个数                         | zcard key                        |
| zscore           | 查看元素的权重                     | zscore key member                |

参数:
withscores

## HyperLogLog

用来做基数统计的算法,在输入元素的数量或者体积非常非常大时,计算基数所需的空间总是固定的,并且是很小的

```shell
pfadd key "values" "foo" "bar"
pfcount key
# 将多个 HyperLogLog 合并为一个
pfmerge destkey sourcekey [sourcekey ...]
```

## Geo

```shell
# geoadd key longitude latitude member [longitude latitude member ...]:将指定的地理空间位置(纬度、经度、名称)添加到指定的key中
geoadd location 116.111 39.111 foo
geoadd location 126.111 39.111 bar
# geodist key member1 member2 [unit]:计算2点间距离
geodist location foo bar m
# geopos key member [member ...]:返回经纬度
geopos location foo
# geohash key member [member ...]:返回Geohash 表示
geohash location foo
# georadius key longitude latitude radius m|km|ft|mi:
georadius location 121.111 39.111 1000 km withcoord
# 同georadius
# georadiusbymember key member radius m|km|ft|mi
georadiusbymember location foo 100 km
```

## Pub/Sub

发布/订阅消息通信模式

| 命令 | 说明               | 例                                          |
| :--- | :----------------- | :------------------------------------------ |
|      | 订阅channel        | subscribe foo                               |
|      | 退订channel        | unsubscribe [channel [channel ...]]         |
|      | 发布消息到channel  | publish foo "foobar"                        |
|      | 支持通配符的订阅   | psubscribe pattern [pattern ...]            |
|      | 支持通配符的退订   | punsubscribe [pattern [pattern ...]]        |
|      | 查看订阅与发布状态 | pubsub subcommand [argument [argument ...]] |

在消费者下线的情况下,生产的消息会丢失,得使用专业的消息队列如rabbitmq等.

# 调用Redis

```java
// 方式1
Jedis jedis = new Jedis("127.0.0.1", 6379);
// 方式2
JedisPool pool = new JedisPool("127.0.0.1", 6379);
Jedis jedis = pool.getResource();

jedis.close();
pool.close();
```

# 使用场景

* 缓存
* 消息队列:list是双向的队列,可以配合消息中间件使用
* 分布式锁:使用自带的setnx,expire
* 分布式session:


# 持久化

|            | RDB                                                          | AOF( Append Only File)                                       |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 作用       | 全量持久化,间隔时间保存,用数据集快照的方式记录redis数据库的所有键值对, 默认方案 | 增量持久化,实时保存,所有的命令行记录以redis命令请求协议的格式保存为aof文件 |
| 持有化文件 | dump.rdb                                                     | appendonly.aof                                               |
| 优点       | 1. 只有一个文件dump.rdb,方便持久化.<br/>2. 容灾性好,一个文件可以保存到安全的磁盘.<br/>3. 性能最大化,fork子进程来完成写操作,让主进程继续处理命令,所以是IO最大化.<br/>4. 相对于数据集大时,比AOF的启动效率更高. | 1. 数据安全,aof持久化频率可以配置appendfsync属性.<br/>2. 通过append模式写文件,即使中途服务器宕机,可以通过redis-check-aof工具解决数据一致性问题.<br/>3. AOF机制的rewrite模式. |
| 缺点       | 1. 数据安全性低<br/>2. 数据量大时,持久化时间长<br/>3. 突然宕机会丢失最后一次持久化后的数据 | 1. 文件会比RDB形式的文件大.<br/>2. 数据集大的时候,比rdb启动效率低. |

appendfsync属性值:

* always: 每个写命令同步一次
* everysec: 每秒同步一次
* no: 系统决定什么时间点同步

RDB方式保存可以通过`save`或`bgsave`命令手动进行,其区别在于前者会阻塞主进程,而后者fork出一个save用子进程,不影响主进程,基于copy on write(COW)原理,此时两个进程共享数据,save结束通知主进程后退出.

默认是RDB,切换为AOF方案:

```shell
# appendonly no
# 使用aof方案
appendonly yes
```

# 主从复制

Redis支持主从同步,从从同步.

完整的复制功能有两个阶段组成:同步及命令传播阶段,前者是将master的数据复制到salve上,后者则是将复制过程中的新的修改体现在slave上.

其使用场景也可以分为首次完整复制和断线后重复制两种情况,前者是空白slave复制一个master,后者则是在主从同步过程中断线重连后的继续复制.

**复制过程**

1. slave向master发送sync命令
2. 收到sync命令的master执行bgsave命令,在后台生成一个rdb文件,并将后续的写操作写入buffer
3. master将bgsave命令生成的rdb文件发送给slave,slave接收并载入这个rdb文件,载入完成后slave和master执行bgsave时状态一致
4. master缓冲区中的写命令发送给slave,slave重新执行这些命令,之后处于和master完全一致的状态
5. 进入命令传播阶段

上述的过程主要有3个传输过程:

1. 从-->主:sync
2. 主-->从:dump.rdb
3. 主-->从:发送缓冲获得写命令

支持心跳检测机制,在命令传播阶段,从服务器会以每秒1次(默认)的频率向master发送命令`replconf ack <replication_offset>`,

用以检测主从之间网络连接状态,及检测命令丢失,master超过1秒钟没有收到salve的命令,就会知道连接出现问题,此时可以`info replication`命令查看slave最后一次发送命令的时间等信息

> 从一般只读
> 为了数据的安全,要禁止master配置为`关闭持久化并自动重启`(很危险).
> 因为master未进行持久化,启动后是没有数据的,此时进行同步就会把slave的也给覆盖掉

**例**

假设master端口为6379,salve为6380,那么:

从redis.conf中配置其master(或命令执行):
```
slaveof 127.0.0.1 6379
```
上述命令执行后有以下过程:

1. slave记录master的地址和端口
2. slave与master建立套接字连接
3. slave发送PING命令
4. master返回pong后,进行身份验证
5. slvae发送自身端口信息
6. 发送PSYNC命令,执行同步
7. 命令传播

> 上述6中,如果进行的是首次完整同步操作,master会将缓冲区中的写命令发给slave
> 如果进行断线重连复制操作,则会吧复制积压缓冲区中的写命令发给slave

[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)
