---
title: Redis基础
date: 2017-05-11
tags:
- Redis
- NoSQL
---
<!-- TOC -->

- [关于](#关于)
- [配置](#配置)
- [使用](#使用)
- [命令](#命令)
    - [共有命令](#共有命令)
- [数据类型](#数据类型)
    - [String](#string)
    - [list](#list)
    - [hash](#hash)
    - [set](#set)
    - [zset](#zset)
    - [HyperLogLog](#hyperloglog)
    - [Geo](#geo)
    - [Pub/Sub](#pubsub)
- [调用Redis](#调用redis)
- [使用场景](#使用场景)
- [持久化](#持久化)
- [主从复制](#主从复制)

<!-- /TOC -->

# 关于

特点:

* key-value形式存储
* 单进程单线程,区别于Memcached的单进程多线程
* 支持string,list,set,zset,hash等数据类型

Redis 将数据储存在内存里面,读写数据的时候都不会受到硬盘 I/O 速度的限制,所以速度极快

使用场景:

* 分布式缓存
* 分布式session
* 数据量大,高并发的场景下

**Redis和Memcache对比**

* 都是内存数据库,但Memcache还可以缓存其他东西,如图片视频
* Redis支持数据持久化,memcache不支持,挂掉后,数据不可恢复
* Redis有数据类型所以会占用更多的空间
* Redis原生支持集群
* 支持分布式,memcache集群,利用magent做一主多从;redis可以做一主多从,也可以一主一从
* redis中数据不是一直在内存中,Memcache则是一直都在

Memcache相关可以阅读[Memcache详细解读](http://www.cnblogs.com/xrq730/p/4948707.html)

# 配置

config命令
```shell
#获取配置信息
config get <settingname>
config set <settingname> <value>
```

设置密码
```shell
config set requirepass 1121
redis-cli -h 127.0.0.1 -p 6379 -a 1121
```

配置后台运行
redis.conf
```shell
# daemonize no
daemonize yes
```

# 使用

启动服务

```shell
redis-server redis.conf
```

关闭服务
```shell
redis-cli -p 6379 shutdown
```

进入命令行
```shell
redis-cli -h host -p port -a password
```

> 默认监听`6379`端口

# 命令

## 共有命令

```shell
# 取出所有key
keys *
# 支持正则表达式
keys "foo*"
# 查看数据类型
type <key>
# 重命名key
rename <key>
# 追加value
append <key>
# 判断存在
exists <key>
set: 插入键值, 存在则覆盖
setnx: 插入键值, 存在不覆盖
mset: 批量插入键值, 覆盖
msetnx: 批量插入键值, 不覆盖
getset <key>: 取值并设置新值

incr <key>: 增1
decr <key>: 减1
incrby <key> <i>: 增i
decrby <key> <i>: 减i
# 设置失效时间
expire key seconds
```

```shell
# 键值对数量
dbsize
# 清空数据库
flushdb
# 服务信息
info
```

# 数据类型

> 不能存储中文, 存储unicode可以实现间接存储中文

## String

常用命令

```Shell
set k v
get k
# 和set的不同在于返回旧值
getset
# 批量设值
mset k1 v1 k2 v2
mget k1 k2
# key存在则什么都不做,不存在与set相同
setnx k v
# mset和setnx的组合效果,如果任意key存在,则全部都不设值
msetnx k1 v1 k2 v2
# 在set基础上设置过期时间,使用ttl查看剩余时间
setex key seconds value
# 同setex,时间单位是毫秒,使用pttl查看剩余时间
psetex key milliseconds value
del
append
# 递增,key不存在则value置为0,value非数组类型则报错
incr k
# 递减
decr k
# 能指定步长的递增
incrby k n
# 能指定步长的递减
decrby k n
# n可以为浮点数
incrbyfloat k n
# offset开始用value覆盖,offset大于总长度则用0补齐
setrange key offset value
# 获取子串,下标可以为负数
getrange k m n
# 长度
strlen k
```

bit操作:字符串类型是以二进制形式存储,bit操作就是对这个二进制进行的操作
```shell
getbit key offset
setbit key offset
# 统计二进制存储中1的个数
bitcount key
# 对二进制进行与或非,异或运算,
bitop [and|or|not|xor] destkey key1 key2
```

nil:空

## list

基于双向循环链表实现, 栈

```shell
# 入栈
lpush  foo bar
rpush  foo bar
# 出栈
lpop foo
rpop foo
# 阻塞式弹出
blpop foo
brpop foo
ltrim key start end

# 出栈, 0 -1:全部取出
lrange key start stop
llen key
lindex key index
```

## hash

```shell
hset
hget

hmset
hmget
hgetall
hdel
hincrby
hlen

```

## set

无序, 不可重复

集合
```shell
# 增加元素
sadd key member [member ...]
# 删除元素
srem key member [member ...]
# 判断存在
sismember key member
# 元素个数
scard key
# 遍历
smembers key
# 随机返回count个value
srandmember key [count]
# 和srandmember相似,但会出栈
spop key [count]
# 跨集合移动元素
smove key1 key2 value
# 集合的差集
sdiff key1 key2
# 保存差集到destkey
sdiffstore destkey key1 key2
# 交集
sinter
sinterstore
# 并集
sunion
sunionstore
```

## zset

有序set

```Shell
zadd key score member
zrange key m n withscores
zrangebyscore key m n withscores
zrem key member
zscore key member
zrevrange
```
参数:
withscores

## HyperLogLog

```shell
pfadd key "values" "foo" "bar"
pfcount key
# 将多个 HyperLogLog 合并为一个
pfmerge destkey sourcekey [sourcekey ...]
```

## Geo

```shell
# geoadd key longitude latitude member [longitude latitude member ...]:将指定的地理空间位置(纬度、经度、名称)添加到指定的key中
geoadd location 116.111 39.111 foo
geoadd location 126.111 39.111 bar
# geodist key member1 member2 [unit]:计算2点间距离
geodist location foo bar m
# geopos key member [member ...]:返回经纬度
geopos location foo
# geohash key member [member ...]:返回Geohash 表示
geohash location foo
# georadius key longitude latitude radius m|km|ft|mi:
georadius location 121.111 39.111 1000 km withcoord
# 同georadius
# georadiusbymember key member radius m|km|ft|mi
georadiusbymember location foo 100 km
```

## Pub/Sub

发布/订阅消息通信模式
```shell
# 订阅channel
subscribe foo
# 退订channel
unsubscribe [channel [channel ...]]
# 发布消息到channel
publish foo "foobar"
# 支持通配符的订阅
psubscribe pattern [pattern ...]
# 支持通配符的退订
punsubscribe [pattern [pattern ...]]
# 查看订阅与发布状态
pubsub subcommand [argument [argument ...]]
```

在消费者下线的情况下,生产的消息会丢失,得使用专业的消息队列如rabbitmq等.


# 调用Redis

```java
// 方式1
Jedis jedis = new Jedis("127.0.0.1", 6379);
// 方式2
JedisPool pool = new JedisPool("127.0.0.1", 6379);
Jedis jedis = pool.getResource();


jedis.close();
pool.close();
```

# 使用场景

* 缓存
* 消息队列:list是双向的队列,可以配合消息中间件使用
* 分布式锁:使用自带的setnx,expire
* 分布式session:


# 持久化

|            | RDB                                                          | AOF( Append Only File)                                       |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 作用       | 全量持久化,间隔时间保存,用数据集快照的方式记录redis数据库的所有键值对, 默认方案 | 增量持久化,实时保存,所有的命令行记录以redis命令请求协议的格式保存为aof文件 |
| 持有化文件 | dump.rdb                                                     | appendonly.aof                                               |
| 优点       | 1. 只有一个文件dump.rdb,方便持久化.<br/>2. 容灾性好,一个文件可以保存到安全的磁盘.<br/>3. 性能最大化,fork子进程来完成写操作,让主进程继续处理命令,所以是IO最大化.<br/>4. 相对于数据集大时,比AOF的启动效率更高. | 1. 数据安全,aof持久化频率可以配置appendfsync属性.<br/>2. 通过append模式写文件,即使中途服务器宕机,可以通过redis-check-aof工具解决数据一致性问题.<br/>3. AOF机制的rewrite模式. |
| 缺点       | 1. 数据安全性低<br/>2. 数据量大时,持久化时间长<br/>3. 突然宕机会丢失最后一次持久化后的数据 | 1. 文件会比RDB形式的文件大.<br/>2. 数据集大的时候,比rdb启动效率低. |

appendfsync属性值:

* always: 每个写命令同步一次
* everysec: 每秒同步一次
* no: 系统决定什么时间点同步

RDB方式保存可以通过`save`或`bgsave`命令手动进行,其区别在于前者会阻塞主进程,而后者fork出一个save用子进程,不影响主进程,基于copy on write(COW)原理,此时两个进程共享数据,save结束通知主进程后退出.

默认是RDB,切换为AOF方案:

```shell
# appendonly no
# 使用aof方案
appendonly yes
```

# 主从复制

Redis可以使用主从同步,从从同步.

第一次同步时,主节点做一次bgsave,并同时将后续修改操作记录到内存buffer,
待完成后将rdb文件全量同步到复制节点,复制节点接受完成后将rdb镜像加载到内存.
加载完成后,再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程.

1. 从-->主:sync
2. 主-->从:dump.rdb
3. 主-->从:发送缓冲获得写命令

> 从一般只读

假设master端口为6379,salve为6380,那么:

从redis.conf中配置其master:
```
slaveof 127.0.0.1 6379
```

访问从
redis-cli -p 6380

<!--
edis Module,像BloomFilter,RedisSearch,Redis-ML
-->

[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)