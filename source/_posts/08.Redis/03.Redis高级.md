---
title: Redis高级
date: 2018-07-27
tags:
- Redis
- NoSQL
---
<!-- TOC -->

- [Redis集群](#redis集群)
- [Q&A](#qa)

<!-- /TOC -->

# Redis集群

Redis Sentinel着眼于高可用,在master宕机时会自动将slave提升为master,继续提供服务.
Redis Cluster着眼于扩展性,在单个redis内存不足时,使用Cluster进行分片存储.

# Q&A

**作为消息队列使用**

list的存储结构是一个双向队列,队首队尾都可以操作,只要一方入,一方出即可用作于消息队列.
在出队列时候可能会遇到队列为空,此时可以在使用普通的lpop或rpop时适当地sleep一定时间,或者直接使用阻塞式出队方式`blpop`或`brpop`.

通常的消息中间件都支持一对一,一对多生产消费模式,使用redis作为消息队列遇到这种一对多模式时,可以采用redis的pub/sub主题订阅者模式,多个客户端可以订阅同一个生产者.

实际上,redis仅仅是可以用作消息队列,但终究不能和专业的消息中间件相比,如一对多模式下,消费者掉线就会发生消息丢失.

同样的某些消息中间件还提供了延时队列,Redis怎么实现?可以使用sortedset,使用时间戳作为score,消息内容作为key来生产消息,消费者用zrangebyscore指令轮询获取特定时间点(如1ms前)的消息.


**Redis实现分布式锁**

使用`setnx`命令来获取锁,获取到之后,用`expire`给锁设置一个过期时间防止锁忘记了释放,
通常可以将需要同步的区域计算成唯一性id作为key使用,但在setnx之后expire之前系统可能出现宕机等异常情况,这就导致过期时间没有被正确设置,从而使锁无法释放,

此时可以将setnx和expire一起作为一个原子操作来进行,要么加锁失败,要么两个命令都正确执行,
或者方案2:将当前时间和失效时间进行组合作为value,就可以不用expire命令.

**redis是单线程的**

由于redis是单线程,一个操作进行时就会阻塞另一个线程,在线上环境使用就要当心.
如使用keys指令查看某些数据,此时可以考虑使用scan命令,它可以无阻塞提取特定规则的数据,但数据可能存在重复.

**Pipeline**

客户端一次发送多条命令并在执行完后将结果一并返回,当然前提是pipeline执行的指令之间没有依赖性,是通过减少C/S之间通信次数来降低交互时间.Pipeline的实现也是基于队列,从而保证了数据的顺序性.
值得注意的是,server是一次性将结果返回的,所以在返回之前都是将前面命令的执行结果保存起来,因此打包的命令越多,内存占用也会越多.

使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目.


[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)