<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [关于](#关于)
- [使用场景](#使用场景)
- [配置](#配置)
- [使用](#使用)
- [持久化](#持久化)
- [主从复制](#主从复制)

<!-- /TOC -->
</details>


## 关于

特点:

* key-value形式存储
* 单进程单线程,区别于Memcached的单进程多线程
* 支持string,list,set,zset,hash等数据类型

Redis 将数据储存在内存里面,读写数据的时候都不会受到硬盘 I/O 速度的限制,所以速度极快

使用场景:

* 分布式缓存
* 分布式session
* 数据量大,高并发的场景下

**Redis和Memcache对比**

* 都是内存数据库,但Memcache还可以缓存其他东西,如图片视频
* Redis支持数据持久化,memcache不支持,挂掉后,数据不可恢复
* Redis有数据类型所以会占用更多的空间
* Redis原生支持集群
* 支持分布式,memcache集群,利用magent做一主多从;redis可以做一主多从,也可以一主一从
* redis中数据不是一直在内存中,Memcache则是一直都在

Memcache相关可以阅读[Memcache详细解读](http://www.cnblogs.com/xrq730/p/4948707.html)

**为什么使用Redis**

主要考虑性能和并发. 如果仅仅是分布式锁这些, 完全可以用中间件Zookpeer等代替

## 使用场景

* 缓存 
* 消息队列:list是双向的队列,可以配合消息中间件使用
* 分布式锁:使用自带的setnx,expire
* 分布式session:

## 配置

config命令
```shell
#获取配置信息
config get <settingname>
config set <settingname> <value>
```

设置密码
```shell
config set requirepass 1121
redis-cli -h 127.0.0.1 -p 6379 -a 1121
```

配置后台运行
redis.conf
```shell
# daemonize no
daemonize yes
```

## 使用

启动服务

```shell
redis-server redis.conf
```

关闭服务
```shell
redis-cli -p 6379 shutdown
```

进入命令行
```shell
redis-cli -h host -p port -a password
```

> 默认监听`6379`端口

## 持久化

|            | RDB                                                          | AOF( Append Only File)                                       |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 作用       | 全量持久化,间隔时间保存,用数据集快照的方式记录redis数据库的所有键值对, 默认方案 | 增量持久化,实时保存,所有的命令行记录以redis命令请求协议的格式保存为aof文件(文本文件, 可直接查看) |
| 持有化文件 | dump.rdb                                                     | appendonly.aof                                               |
| 优点       | 1. 只有一个文件dump.rdb,方便持久化.<br/>2. 容灾性好,一个文件可以保存到安全的磁盘.<br/>3. 性能最大化,fork子进程来完成写操作,让主进程继续处理命令,所以是IO最大化.<br/>4. 相对于数据集大时,比AOF的启动效率更高. | 1. 数据安全,aof持久化频率可以配置appendfsync属性.<br/>2. 通过append模式写文件,即使中途服务器宕机,可以通过redis-check-aof工具解决数据一致性问题.<br/>3. AOF机制的rewrite模式. |
| 缺点       | 1. 数据安全性低<br/>2. 数据量大时,持久化时间长<br/>3. 突然宕机会丢失最后一次持久化后的数据 | 1. 文件会比RDB形式的文件大.<br/>2. 数据集大的时候,比rdb启动效率低. |

appendfsync属性值:

* always: 每个写命令同步一次
* everysec: 每秒同步一次
* no: 系统决定什么时间点同步

RDB方式保存可以通过`save`或`bgsave`命令手动进行,其区别在于前者会阻塞主进程,而后者fork出一个save用子进程,不影响主进程,基于copy on write(COW)原理,此时两个进程共享数据,save结束通知主进程后退出.

默认是RDB,切换为AOF方案:

```shell
# appendonly no
# 使用aof方案
appendonly yes
```

## 主从复制

Redis支持主从同步,从从同步.

完整的复制功能有两个阶段组成:同步及命令传播阶段,前者是将master的数据复制到salve上,后者则是将复制过程中的新的修改体现在slave上.

其使用场景也可以分为首次完整复制和断线后重复制两种情况,前者是空白slave复制一个master,后者则是在主从同步过程中断线重连后的继续复制.

**复制过程**

1. slave向master发送sync命令
2. 收到sync命令的master执行bgsave命令,在后台生成一个rdb文件,并将后续的写操作写入buffer
3. master将bgsave命令生成的rdb文件发送给slave,slave接收并载入这个rdb文件,载入完成后slave和master执行bgsave时状态一致
4. master缓冲区中的写命令发送给slave,slave重新执行这些命令,之后处于和master完全一致的状态
5. 进入命令传播阶段

上述的过程主要有3个传输过程:

1. 从-->主:sync
2. 主-->从:dump.rdb
3. 主-->从:发送缓冲获得写命令

支持心跳检测机制,在命令传播阶段,从服务器会以每秒1次(默认)的频率向master发送命令`replconf ack <replication_offset>`,

用以检测主从之间网络连接状态,及检测命令丢失,master超过1秒钟没有收到salve的命令,就会知道连接出现问题,此时可以`info replication`命令查看slave最后一次发送命令的时间等信息

> 从一般只读
> 为了数据的安全,要禁止master配置为`关闭持久化并自动重启`(很危险).
> 因为master未进行持久化,启动后是没有数据的,此时进行同步就会把slave的也给覆盖掉

**例**

假设master端口为6379,salve为6380,那么:

从redis.conf中配置其master(或命令执行):
```
slaveof 127.0.0.1 6379
```
上述命令执行后有以下过程:

1. slave记录master的地址和端口
2. slave与master建立套接字连接
3. slave发送PING命令
4. master返回pong后,进行身份验证
5. slvae发送自身端口信息
6. 发送PSYNC命令,执行同步
7. 命令传播

> 上述6中,如果进行的是首次完整同步操作,master会将缓冲区中的写命令发给slave
> 如果进行断线重连复制操作,则会把复制积压缓冲区中的写命令发给slave

[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)
