---
title: Redis基础
date: 2017-05-11
tags:
- Redis
- NoSQL
---
<!-- TOC -->

- [集群](#集群)
- [搭建](#搭建)
- [登录集群](#登录集群)
- [Sentinel集群](#sentinel集群)
- [区别](#区别)
- [Q&A](#qa)
- [Q&A](#qa-1)

<!-- /TOC -->
# 集群

从3.0版本开始支持集群,集群中内置了16384(2^14)个哈希槽,

存储数据时首先针对key使用crc16算法计算出一个hash值,然后对16384取余,这样就可以大致均等的将数据分布在集群中.

![](https://raw.githubusercontent.com/LuVx21/hexo/master/source/_posts/99.img/redis_cluster.png)

集群中不可避免的会有节点失效,如果半数以上的节点无法和某节点交互,则认为该节点宕机.

# 搭建

首先使用docker准备5个容器

```shell
# name,port依次增加
docker run --name redis1 -p 127.0.0.1:6380:6379 -d redis:latest
```

> 将本地主机的6380~6384分别映射为5个redis容器

然后修改各个节点的配置文件
```conf
daemonize yes
cluster-enabled yes
```

启动集群:

```shell
# 创建集群
./src/redis-trib.rb create --replicas 1 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384
```

> 启动前确保没有持久化文件及上一个集群的信息:dump.rdb appendonly.aof nodes.conf

# 登录集群

```shell
redis-cli -c -h 127.0.0.1 -p 6380
# 查询集群结点信息
cluster nodes
# 查询集群状态信息
cluster info
```

# Sentinel集群

Master-slave高可用性(HA)解决方案
单点问题(single-point-of-failure)

```shell
redis-server /path/to/sentinel.conf --sentinel
# redis-sentinel /path/to/sentinel.conf
```

26379端口

> 4.0.8版本中redis-sentinel就是指向的redis-server

```conf
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 60000
sentinel failover-timeout mymaster 180000
sentinel parallel-syncs mymaster 1
```

# 区别

Redis Cluster着眼于扩展性,在单个redis内存不足时,使用Cluster进行分片存储.
Redis Sentinel着眼于高可用,在master宕机时会自动将slave提升为master,继续提供服务.

# Q&A

**Redis主从是怎么选取的**
* 主动切换
* 使用sentinel自动方式

# Q&A


[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)