---
title: 面试准备:操作系统
date: 2018-03-20
tags:
- Java
---
<!-- TOC -->

- [内存管理](#内存管理)
- [Q&A](#qa)
- [参考](#参考)

<!-- /TOC -->
# 内存管理

分段，分页
虚拟内存

页面置换算法:

FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；
LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；
LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；
OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。


进程间通信方式:

* 管道(pipe)
* 信号(signal)
* 消息队列
* 共享内存
* 信号量
* 套接字


***进程调度策略***

* FCFS(先来先服务，队列实现，非抢占的):先请求CPU的进程先分配到CPU
* SJF(最短作业优先):平均等待时间最短，但难以知道下一个CPU区间长度
* 优先级调度算法(可以是抢占的，也可以是非抢占的):优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是:低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案:老化
* 时间片轮转调度算法(可抢占的):队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。
* 多级队列调度算法:将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。
* 多级反馈队列调度算法:与多级队列调度算法相比，其允许进程在队列之间移动:若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。




# Q&A


***导致死锁的四个必要条件***

* 互斥:至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；
* 占有并等待:一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；
* 非抢占:进程不能被抢占，即资源只能被进程在完成任务后自愿释放
* 循环等待:若干进程之间形成一种头尾相接的环形等待资源关系


***处理死锁的四个方式***


***预防死锁的方法、避免死锁的方法**

针对死锁产生的条件进行预防:
* 打破互斥:将资源设为共享,不符合实际需求,实用意义不大
* 打破占有并等待:配置等待超时,指定时间后无法获取锁,就退出等待状态并释放自身拥有的锁
* 打破非抢占:允许抢占资源
* 打破循环等待:实行资源有序分配策略

死锁避免:

动态地检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态

检测死锁、 、鸵鸟策略

死锁解除:

* 进程终止:终止处于死锁状态下的某进程或全部进程以打破循环等待状态
* 资源抢占:


<!--
* 操作系统的四个特性
* 操作系统的主要功能
* 进程的有哪几种状态，状态转换图，及导致转换的事件
* 进程与线程的区别
* 进程通信的几种方式
* 进程同步的几种方式
* 用户态和核心态的区别
* 死锁的概念，导致死锁的原因
* 进程调度算法
* 内存连续分配方式采用的几种算法及各自优劣
* 基本分页储存管理方式
* 基本分段储存管理方式
* 分段分页方式的比较各自优缺点
* 几种页面置换算法，会算所需换页数
* 虚拟内存的定义及实现方式
为什么要内存对齐;
为什么会有大端小端，htol这一类函数的作用;
-->


# 参考

[]()