---
title: 面试准备:数据库
date: 2018-03-20
tags:
- MySQL
categories:
- 面试
---

<!-- TOC -->

- [事务](#事务)
    - [隔离级别的实现](#隔离级别的实现)
- [锁](#锁)
- [优化](#优化)
- [读写分离](#读写分离)
    - [分表](#分表)
    - [分库](#分库)
    - [主从复制](#主从复制)
- [引擎](#引擎)
- [故障恢复](#故障恢复)
- [NoSQL](#nosql)

<!-- /TOC -->


# 事务

ACID:

* 原子性(Atomicity)
* 一致性(Consistency)
* 隔离性(Isolation)
* 持久性(Durability)

事务隔离级别:

* 未提交读(Read uncommitted):最低级别,任何情况都无法保证,会发生脏读,不可重复读
* 提交读(Read committed):可避免脏读,会发生不可重复读
* 可重复读(Repeatable read):会发生幻读(虚读),可避免脏读、不可重复读,MySQL默认隔离级别
* 可串行化(Serializable):强制事务串行执行,可避免脏读、不可重复读、幻读

> * 脏读:当前事务读取到未提交事务中的修改
> * 不可重复读:在同一事务中两次读取的数据不一致(由其他事务修改现有数据引起)
> * 幻读:简单的可以理解为在同一事务中两次读取的数据条数不一致(有其他事务增删数据引起)

## 隔离级别的实现

锁
时间戳

**mysql如何解决幻读,如何解决不可重复读, 了解MVCC和next-key锁**

InnoDB和XtraDB存储引擎通过版本并发控制MVCC(Multiversion Concurrency Control)解决了幻读问题.
通常涉及到写操作都是要阻塞的,如读写,写读,使用MVCC后,只有写写会阻塞.
节选自[MySQL-InnoDB-MVCC多版本并发控制](https://segmentfault.com/a/1190000012650596)

# 锁

锁的级别:
表级:直接锁定整张表,在你锁定期间,其它进程无法对该表进行写操作.如果你是写锁,则其它进程则读也不允许
行级:仅对指定的记录进行加锁,这样其它进程还是可以对同一个表中的其它记录进行操作.
页级:表级锁速度快,但冲突多,行级冲突少,但速度慢.所以取了折衷的页级,一次锁定相邻的一组记录.

# 优化

* 分表:行分表,列分表
* 索引
* sql语句

慢查询

# 读写分离

## 分表

水平切分:把一个表的数据分到多个表中,每个表的字段相同,能够提高查询性能,但由于数据仍然处于同一个库中,库级别仍有IO瓶颈
垂直切分:把一个表的字段分到多个表中,每个表的字段不同

分表策略:
* 随机切分:hash,mod
* 连续切分

带来的问题:

表关联
分布式事务:数据一致性
数据id问题:如MySQL不能使用自增的id,而应该使用全局唯一id,如UUID等

## 分库

水平分:适用于单表中数据量极大的场景,被分成的表处于不同的库中,这也是和水平分表的不同
垂直分:适用于单库中表的数量较多的场景,如把一个表分到一个单独的库中

实现简单
存在跨库join查询问题,无法解决单表数据量大的问题

解决跨库join的方案:

常被join的表在每个库中都存留一份.但要求这些表很少被修改
表中保存"多余"的字段,避免通过join去其他表获取该字段,是一种空间换性能的方案

## 主从复制

读写分离存在的问题:

连接池隔离
主从同步延迟

解决方案:

适当放弃一致性
一致性要求强的机能无论读写都使用master库
弱一致性(最终一致性)的机能使用读写分离

***数据库的三大范式;***
设计数据库时所遵循的规则

以用户,订单,商品表为例:

第一范式要求数据库表中的所有字段值保持原子性,如用户的居住地等,省,市,地区等都要单作为一列,毕竟有时候,并不需要你具体的居住地.
第二范式要求数据库表中的每个字段都和主键相关,而不能只与主键的某一部分相关.如订单表中,同一订单有多个商品,不需要将商品具体信息存储在此,抽出来存储在商品表即可.商品信息仅与商品id相关,而与订单id无关.
第三范式要求数据表中的每个字段都和主键直接相关,而不能间接相关,如订单表中不要存储购买者,商品的信息,只需要提供一个连接key,连接到用户表,商品表中即可

区分2NF和3NF
> 2NF剔除未与主键完全相关的数据,3NF剔除和主键间接相关的数据
> 2NF处理不合理的复合主键,3NF:处理单主键表的非主键列.

<!--
悲观锁和乐观锁的原理和应用场景;
数据库中的隔离性是怎样实现的;原子性、一致性、持久性又是如何实现的;
MySQL并发情况下怎么解决(通过事务、隔离级别、锁);
MySQL中的MVCC机制是什么意思,根据具体场景,MVCC是否有问题;
-->
# 引擎


MyISAM:索引为非聚集型,索引和数据分开存储,B+Tree索引结构的叶节点data域存储的数据地址<br/>
InnoDB:索引为聚集型,数据本身就是B+Tree索引结构,所以叶节点包含了完整的数据,data域记录的也是主键值,这也要求表必须有主键,没有则会创建一个长度为6,长整型的隐式主键.

# 故障恢复

故障恢复的目标:

已提交的事务数据依然存在,
未提交的数据自动回滚


# NoSQL

HBase

***怎么排查慢查询***

慢查询日志,定位慢 SQL

***如何让数据库能够存储emoji***

utf8字符集只能存储1~3个字节的字符,不能存储4个字节的emoji,因此使用`utf8mb4`字符集,同时还兼容utf8
```sql
-- 库
alter database <database_name> character set utf8mb4;
-- 表
alter table <table_name> character set utf8mb4;
-- 字段
alter table <table_name> modify <field_name> char(10) character set utf8mb4;
```

***drop,truncate,delete的区别?***

* delete:DML,可以指定删除数据,不指定则清空表数据,每删除一行都会在事务日志中记录,事务未提交可以回滚,会触发相关触发器.
* truncate:DDL,清空表数据,隐式提交,不能回滚,不会触发相关触发器,删除后,表和索引占用的空间会恢复至初始值,对于被外键引用的表,无法使用truncate.
* drop:DDL,删除表(包括表结构和数据),隐式提交,不能回滚,不会触发相关触发器,删除后,释放表占用的全部空间,删除的同时,相关索引,触发器等也一并删除.

> 删除速度:drop > truncate > delete
> 使用truncate和drop删除后,虽然不能回滚,但可以通过其他手段恢复数据.

***InnoDB的插入缓冲和两次写的概率和意义;***


***全文检索中的倒排索引是什么原理;***

全文检索的索引被称为倒排索引,是一种面向单词的索引机制,是将每一个单词作为索引项查找包含该单词的文档的索引.
常规索引是文档→关键词的结构,需要一个文档一个文档检索,
而倒排索引是关键词→文档的结构,通常由"词典"和"出现情况"两部分组成,使用关键字查找所出现的文档,位置,次数等信息.


[![](https://static.segmentfault.com/v-5b1df2a7/global/img/creativecommons-cc.svg)](https://creativecommons.org/licenses/by-nc-nd/4.0/)