---
title: 面试准备:计算机网络
date:
tags:
-
---
<!-- TOC -->

- [OSI网络体系结构与TCP/IP协议模型](#osi网络体系结构与tcpip协议模型)
- [协议](#协议)
- [TCP](#tcp)
- [UDP](#udp)
- [Http(s)](#https)
    - [Http](#http)
    - [Https](#https)

<!-- /TOC -->

# OSI网络体系结构与TCP/IP协议模型

原理体系结构:

* 应用层
* 传输层
* 网络层
* 数据链路层
* 物理层

OSI七层模型:

* 应用层
* 表示层
* 会话层
* 传输层
* 网络层
* 数据链路层
* 物理层

> Open System Interconnection(开放式系统互联)

TCP/IP模型:

* 应用层
* 传输层
* 网络层
* 物理层

OSI七层模型分别对应着五层模型的哪一部分;

# 协议

应用层协议

TCP和UDP对应的常见应用层协议

TCP:

* HTTP
* FTP
* SMTP
* POP3
* Telnet

UDP:

* DNS:域名系统,占用53端口,用于域名解析
* SNMP:简单网络管理协议,占用161端口,用于管理网络设备
* TFTP:简单文件传输协议,占用69端口


传输层协议

* TCP
* UDP

网络层协议
ARP:Address Resolution Protocol,地址解析协议,完成了IP地址与物理地址的映射



<!--
有没有听说过七层协议, ip分别属于哪一层.
传输层的作用
传输层复用和分用的含义
传输层和网络层的区别
cookie,session的区别
IP
UDP协议的特点
UDP协议的报文结构

停止等待协议
滑动窗口协议
-->

# TCP

Transmission Control Protocol(传输控制协议),传输层协议

三次握手:你好?我好,你好?我也好!
四次挥手:撤了,再见?OK,再见!我也撤了,再见?OK,再见!

> 为什么3次,而不是2次:防止已失效的链接请求报文突然又传送到了服务端,从而产生错误
> 假设客户端的某次请求因为网络延迟直至连接断开后才被服务端收到,服务端则返回确认,若是两次握手,服务端的这次响应就会创建新的连接,服务端处于客户端的请求的状态,但实际上客户端并没有发出请求,造成服务端资源浪费.

**TCP可靠传输是如何实现的**

* 数据包校验
* 对失序数据包重排序
* 丢弃重复数据
* 应答机制
* 超时重发
* 流量控制

**TCP流量控制,拥塞控制**

TCP连接的每一方都有固定大小的缓冲空间.TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据,这可以防止较快主机致使较慢主机的缓冲区溢出,这就是流量控制.
TCP使用的流量控制协议是可变大小的滑动窗口协议






# UDP

User Datagram Protocol,用户数据报协议,传输层协议

和TCP协议的区别:
* TCP面向连接,UDP无连接
* TCP可靠,UDP不可靠
* TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式
* TCP是面向字节流的，UDP是面向报文的
* TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信
* TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大


<!--
有没有听过tcp三次握手, 过程是什么, 为什么要三次握手?那四次挥手呢?
TCP三次握手数据丢失了怎么办?那如果后面又找到了呢?
TCP协议的特点
TCP协议的报文结构
TCP粘包拆包
-->

# Http(s)

## Http

Http协议运行在TCP之上,明文传输,客户端与服务器端都无法验证对方的身份;

HTTP工作流程
HTTP请求格式
HTTP 1.1中的8种请求方式
HTTP响应格式
HTTP中重要的请求头和响应头字段
HTTP常用状态码及其含义

## Https

Https是身披SSL(Secure Socket Layer)外壳的Http,运行于SSL上,SSL运行于TCP之上,是添加了加密和认证机制的HTTP.

HTTPS协议的工作流程

二者之间存在如下不同:
端口不同:Http与Http使用不同的连接方式,用的端口也不一样,前者是80,后者是443;
资源消耗:和HTTP通信相比,Https通信会由于加减密处理消耗更多的CPU和内存资源;
开销:Https通信需要证书,而证书一般需要向认证机构购买;
Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制.

**Get与POST的区别**

* 功能:GET一般用来从服务器上获取资源,不会改变服务器上的资源,POST一般用来更新服务器上的资源
* REST服务:GET总是得到同样的内容,POST每次请求对资源的改变并不一定是相同的
* 请求参数形式:GET请求数据放在HTTP请求头上,以`?`分割URL和数据,以`&`连接数据;POST将数据放在HTTP请求报文的请求体中
* 安全性:POST更加安全
* 请求大小:GET请求受限于url的长度,POST则无限制

> GET请求中的数据,非英文或数字会被重新编码,这是为了避免歧义,如空格被编码为`+`,类似于中文等则被BASE64加密.
> 数据本身含有`&`,`=`会被编码为`%26`,`%3D`以和key=value中的符合区分开

<!--
有没有用过ping命令?ping命令用的是什么协议(icmp), 有没有经过tcp层?除了判断可达性还有哪些实用(Traceroute), 原理是什么
HTTP1.0和HTTP1.1的区别;
DHCP如何实现分配IP的; 发现阶段(DHCP客户端在网络中广播发送DHCP DISCOVER请求报文,发现DHCP服务器,请求IP地址租约)、提供阶段(DHCP服务器通过DHCP OFFER报文向DHCP客户端提供IP地址预分配)、选择阶段(DHCP客户端通过DHCP REQUEST报文确认选择第一个DHCP服务器为它提供IP地址自动分配服务)和确认阶段(被选择的DHCP服务器通过DHCP ACK报文把在DHCP OFFER报文中准备的IP地址租约给对应DHCP客户端).
OSI七层模型,每层都说下自己的理解和知道的,说的越多越好;
HTTP、TCP、UDP的区别和联系;
TCP和UDP各自的优势,知道哪些使用UDP协议的成功案例;
TCP和UDP各用了底层什么协议;
单个UDP报文最大容量;
单个TCP报文最大容量;
TCP报头格式、UDP报头格式;
Server遭遇SYN Flood应当怎么处理;
Web开发中如何防范XSS攻击?
拆包和粘包的问题,如何解决,如果我们的包没有固定长度的话,我们的应用程序应该如何解决;
数据链路层是做什么的?
数据链路层的流量控制?
网络模型的分层、IP和Mac地址在那个层、TCP和HTTP分别在那个层;
TCP的同传,拆包与组装包是什么意思;
Http 为什么是无状态的;
Http1.0和Http2.0的区别;
两个不同ip地址的计算机之间如何通信;
地址解析协议ARP;
-->

**在浏览器输入一个网址发生了什么**

1. 浏览器查找该域名的 IP 地址(用ARP协议获取物理地址和DNS协议获取网络地址,即IP地址)
2. 浏览器根据解析得到的IP地址向 web 服务器发送一个 HTTP 请求.(用到TCP、IP、以太网协议报头)
3. 服务器收到请求并进行处理
4. 服务器返回一个响应(服务器返回一个 HTTP 响应,如果返回状态码304,浏览器可以直接使用之前缓存的资源.对于内容响应,浏览器需要进行响应解码,渲染显示.)
5. 浏览器对该响应进行解码,渲染显示.( 在浏览器没有完整接受全部HTML文档时,(打开网页,网页显示用到了表示层的HTML协议)它就已经开始显示这个页面了,如果是个静态的页面,那到此就基本结束了.如果是是动态的,那么在浏览器显示HTML时,会获取嵌入在HTML中的对象,浏览器会发送获取请求来重新获得这些文件.这些请求都要经历一个和HTML读取类似的过程. 对于静态的页面内容,浏览器通常会进行缓存,而对于动态的内容,浏览器通常不会进行缓存)
6. 完成后,浏览器发送异步请求(页面显示完成后客户端仍与服务器端保持着联系. 它会持续与服务器保持联系来及时更新一些页面信息.在浏览器中执行的 JavaScript代码会给服务器发送异步请求.这个异步请求发送给特定的地址,它是一个按照程式构造的获取或发送请求.)

> 此过程用到的协议:
> 应用层使用了HTTP协议进行超文本传输,对于服务器后台处理应该有telnet远程调用协议响应用户,DNS协议获取网络地址,即IP地址;
> 另外必然用到了传输层的TCP和网络层的IP协议;网络层ARP协议获取物理地址;ICMP协议控制信息的传递.

**对称加密与非对称加密**

对称密钥加密是指加密和解密使用同一个密钥的方式,这种方式存在的最大问题就是密钥发送问题,即如何安全地将密钥发给对方；
非对称加密是指使用一对非对称密钥,即公钥和私钥,公钥可以随意发布,但私钥只有自己知道.发送密文的一方使用对方的公钥进行加密处理,对方接收到加密信息后,使用自己的私钥进行解密.

由于非对称加密的方式不需要发送用来解密的私钥,所以可以保证安全性；但是和对称加密比起来,它非常的慢,所以我们还是要用对称加密来传送消息,但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去.

**DDoS攻击**

分布式拒绝服务攻击,三次握手的最后一次不进行(不发送确认数据)从而使服务端一直处于等待的状态.
无法彻底解决,预防方式有以下:
* 限制同时打开SYN半链接的数目
* 缩短SYN半链接的Time out 时间
* 关闭不必要的服务