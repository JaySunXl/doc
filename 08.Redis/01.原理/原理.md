<details>
<summary>点击展开目录</summary>
<!-- TOC -->

- [持久化](#持久化)
    - [RDB](#rdb)
    - [AOF](#aof)
- [主从复制](#主从复制)
- [事务](#事务)

<!-- /TOC -->
</details>

## 持久化

### RDB

全量持久化, 间隔时间保存, 用数据集快照的方式记录redis数据库的所有键值对, 默认持久化方案

持久化文件名: `dump.rdb`

* 优点
    1. 只有一个文件`dump.rdb`, 方便持久化.
    2. 容灾性好, 一个文件可以保存到安全的磁盘.
    3. 性能最大化, fork子进程来完成写操作, 让主进程继续处理命令, 所以是IO最大化.
    4. 相对于数据集大时, 比AOF的启动效率更高.
* 缺点
    1. 数据安全性低
    2. 数据量大时, 持久化时间长
    3. 突然宕机会丢失最后一次持久化后的数据

关于RDB, 默认有以下配置:
```conf
save 900 1    # 900秒内如果至少有1个key发生变化, 则触发bgsave命令创建快照
save 300 10   # 300秒内如果至少有10个key发生变化, 则触发bgsave命令创建快照
save 60 10000 # 60秒内如果至少有10000个key发生变化, 则触发bgsave命令创建快照
```

RDB方式保存可以通过`save`或`bgsave`命令手动进行,

其区别在于前者会阻塞主进程, 而后者fork出一个save用子进程, 不影响主进程, 基于`copy on write(COW)`原理, 此时两个进程共享数据, save结束通知主进程后退出.

### AOF

Append Only File, 增量持久化, 实时保存, 所有的命令行记录以redis命令请求协议的格式保存为aof文件(文本文件, 可直接查看)

持久化文件名: `appendonly.aof`

可使用命令切换为AOF方案:

```shell
# appendonly no
# 使用aof方案
appendonly yes
```

* 优点
    1. 数据安全, aof持久化频率可以配置`appendfsync`属性.
    2. 通过append模式写文件, 即使中途服务器宕机, 可以通过`redis-check-aof`工具解决数据一致性问题.
    3. AOF机制的rewrite模式.
    4. 实时性好
* 缺点
    1. 文件会比RDB形式的文件大.
    2. 数据集大的时候, 比rdb启动效率低.
 
`appendfsync`属性值:

* `always`: 每个写命令同步一次
* `everysec`: 每秒同步一次
* `no`: 系统自行决定什么时间点同步

## 主从复制

Redis支持主从同步, 从从同步.

完整的复制功能有两个阶段组成:同步及命令传播阶段, 前者是将master的数据复制到salve上, 后者则是将复制过程中的新的修改体现在slave上.

其使用场景也可以分为首次完整复制和断线后重复制两种情况, 前者是空白slave复制一个master, 后者则是在主从同步过程中断线重连后的继续复制.

**复制过程**

1. slave向master发送sync命令
2. 收到sync命令的master执行bgsave命令, 在后台生成一个rdb文件, 并将后续的写操作写入buffer
3. master将bgsave命令生成的rdb文件发送给slave, slave接收并载入这个rdb文件, 载入完成后slave和master执行bgsave时状态一致
4. master缓冲区中的写命令发送给slave, slave重新执行这些命令, 之后处于和master完全一致的状态
5. 进入命令传播阶段

上述的过程主要有3个传输过程:

1. 从-->主:sync
2. 主-->从:dump.rdb
3. 主-->从:发送缓冲获得写命令

支持心跳检测机制, 在命令传播阶段, 从服务器会以每秒1次(默认)的频率向master发送命令`replconf ack <replication_offset>`, 

用以检测主从之间网络连接状态, 及检测命令丢失, master超过1秒钟没有收到salve的命令, 就会知道连接出现问题, 此时可以`info replication`命令查看slave最后一次发送命令的时间等信息

> 从一般只读
> 为了数据的安全, 要禁止master配置为`关闭持久化并自动重启`(很危险).
> 因为master未进行持久化, 启动后是没有数据的, 此时进行同步就会把slave的也给覆盖掉

**例**

假设master端口为6379, salve为6380, 那么:

从redis.conf中配置其master(或命令执行):
```
slaveof 127.0.0.1 6379
```
上述命令执行后有以下过程:

1. slave记录master的地址和端口
2. slave与master建立套接字连接
3. slave发送PING命令
4. master返回pong后, 进行身份验证
5. slave发送自身端口信息
6. 发送PSYNC命令, 执行同步
7. 命令传播

> 上述6中, 如果进行的是首次完整同步操作, master会将缓冲区中的写命令发给slave
> 如果进行断线重连复制操作, 则会把复制积压缓冲区中的写命令发给slave

## 事务

通过`multi`, `exec`, `watch` 等命令来实现事务功能

事务提供了一种将多个命令请求打包, 然后一次性, 按顺序地执行多个命令的机制,

在事务执行期间, 服务器不会中断事务而改去执行其他客户端的命令请求, 它会将事务中的所有命令都执行完毕, 然后才去处理其他客户端的命令请求

redis同一个事务中如果有一条命令执行失败, 其后的命令仍然会被执行, 没有回滚
